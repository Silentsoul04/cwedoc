# ID: 415 - Double Free
<h5>Name</h5>Double Free
<h5>Weakness</h5>Variant
<h5>Status</h5>Draft
<h5>Description</h5>The product calls free() twice on the same memory address, potentially leading to modification of unexpected memory locations.
<h5>ExtendedDescription</h5>When a program calls free() twice with the same argument, the program's memory management data structures become corrupted. This corruption can cause the program to crash or, in some circumstances, cause two later calls to malloc() to return the same pointer. If malloc() returns the same value twice and the program later gives the attacker control over the data that is written into this doubly-allocated memory, the program becomes vulnerable to a buffer overflow attack.
<h5>RelatedWeaknesses</h5>::NATURE:ChildOf:CWE ID:666:VIEW ID:1000::NATURE:ChildOf:CWE ID:675:VIEW ID:1000::NATURE:ChildOf:CWE ID:825:VIEW ID:1000:ORDINAL:Primary::NATURE:PeerOf:CWE ID:416:VIEW ID:1000::NATURE:PeerOf:CWE ID:416:VIEW ID:699::NATURE:PeerOf:CWE ID:123:VIEW ID:1000::
<h5>WeaknessOrdinalities</h5>null
<h5>ApplicablePlatforms</h5>::LANGUAGE NAME:C:LANGUAGE PREVALENCE:Undetermined::LANGUAGE NAME:C++:LANGUAGE PREVALENCE:Undetermined::
<h5>BackgroundDetails</h5>null
<h5>AlternateTerms</h5>::TERM:Double-free:DESCRIPTION:::
<h5>ModesOfIntroduction</h5>:::PHASE:Architecture and Design:DESCRIPTION::::PHASE:Implementation:DESCRIPTION:::
<h5>ExploitationFactors</h5>null
<h5>LikelihoodofExploit</h5>null
<h5>CommonConsequences</h5>::SCOPE:Integrity:SCOPE:Confidentiality:SCOPE:Availability:TECHNICAL IMPACT:Execute Unauthorized Code or Commands:NOTE:Integrity Confidentiality Availability Execute Unauthorized Code or Commands Doubly freeing memory may result in a write-what-where condition, allowing an attacker to execute arbitrary code.::
<h5>DetectionMethods</h5>null
<h5>PotentialMitigations</h5>::PHASE:Architecture and Design:STRATEGY::EFFECTIVENESS::DESCRIPTION:Choose a language that provides automatic memory management.::PHASE:Implementation:STRATEGY::EFFECTIVENESS::DESCRIPTION:Ensure that each allocation is freed only once. After freeing a chunk, set the pointer to NULL to ensure the pointer cannot be freed again. In complicated error conditions, be sure that clean-up routines respect the state of allocation properly. If the language is object oriented, ensure that object destructors delete each chunk of memory only once.::PHASE:Implementation:STRATEGY::EFFECTIVENESS::DESCRIPTION:Use a static analysis tool to find double free instances.::
<h5>ObservedExamples</h5>::REFERENCE:CVE-2006-5051:DESCRIPTION:Chain: Signal handler contains too much functionality (CWE-828), introducing a race condition that leads to a double free (CWE-415).:LINK:https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2006-5051REFERENCE:CVE-2004-0642:DESCRIPTION:Double free resultant from certain error conditions.:LINK:https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2004-0642REFERENCE:CVE-2004-0772:DESCRIPTION:Double free resultant from certain error conditions.:LINK:https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2004-0772REFERENCE:CVE-2005-1689:DESCRIPTION:Double free resultant from certain error conditions.:LINK:https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2005-1689REFERENCE:CVE-2003-0545:DESCRIPTION:Double free from invalid ASN.1 encoding.:LINK:https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2003-0545REFERENCE:CVE-2003-1048:DESCRIPTION:Double free from malformed GIF.:LINK:https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2003-1048REFERENCE:CVE-2005-0891:DESCRIPTION:Double free from malformed GIF.:LINK:https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2005-0891REFERENCE:CVE-2002-0059:DESCRIPTION:Double free from malformed compressed data.:LINK:https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2002-0059
<h5>FunctionalAreas</h5>null
<h5>AffectedResources</h5>Memory::
<h5>TaxonomyMappings</h5>TAXONOMY NAME:PLOVER:ENTRY NAME:DFREE - Double-Free Vulnerability::::TAXONOMY NAME:7 Pernicious Kingdoms:ENTRY NAME:Double Free::::TAXONOMY NAME:CLASP:ENTRY NAME:Doubly freeing memory::::TAXONOMY NAME:CERT C Secure Coding:ENTRY ID:MEM00-C:ENTRY NAME:Allocate and free memory in the same module, at the same level of abstraction::::TAXONOMY NAME:CERT C Secure Coding:ENTRY ID:MEM01-C:ENTRY NAME:Store a new value in pointers immediately after free()::::TAXONOMY NAME:CERT C Secure Coding:ENTRY ID:MEM30-C:ENTRY NAME:Do not access freed memory:MAPPING FIT:CWE More Specific::::TAXONOMY NAME:CERT C Secure Coding:ENTRY ID:MEM31-C:ENTRY NAME:Free dynamically allocated memory exactly once::::TAXONOMY NAME:Software Fault Patterns:ENTRY ID:SFP12:ENTRY NAME:Faulty Memory Release::
<h5>RelatedAttackPatterns</h5>null
<h5>Notes</h5>TYPE:Relationship:NOTE:This is usually resultant from another weakness, such as an unhandled error or race condition between threads. It could also be primary to weaknesses such as buffer overflows.::::TYPE:Maintenance:NOTE:It could be argued that Double Free would be most appropriately located as a child of Use after Free, but Use and Release are considered to be distinct operations within vulnerability theory, therefore this is more accurately Release of a Resource after Expiration or Release, which doesn't exist yet.::

