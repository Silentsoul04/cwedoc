# ID: 190 - Integer Overflow or Wraparound
<h5>Name</h5>Integer Overflow or Wraparound
<h5>Weakness</h5>Base
<h5>Status</h5>Incomplete
<h5>Description</h5>The software performs a calculation that can produce an integer overflow or wraparound, when the logic assumes that the resulting value will always be larger than the original value. This can introduce other weaknesses when the calculation is used for resource management or execution control.
<h5>ExtendedDescription</h5>An integer overflow or wraparound occurs when an integer value is incremented to a value that is too large to store in the associated representation. When this occurs, the value may wrap to become a very small or negative number. While this may be intended behavior in circumstances that rely on wrapping, it can have security consequences if the wrap is unexpected. This is especially the case if the integer overflow can be triggered using user-supplied inputs. This becomes security-critical when the result is used to control looping, make a security decision, or determine the offset or size in behaviors such as memory allocation, copying, concatenation, etc.
<h5>RelatedWeaknesses</h5>::NATURE:ChildOf:CWE ID:682:VIEW ID:1000:ORDINAL:Primary::NATURE:ChildOf:CWE ID:682:VIEW ID:699:ORDINAL:Primary::NATURE:ChildOf:CWE ID:682:VIEW ID:1003:ORDINAL:Primary::NATURE:ChildOf:CWE ID:20:VIEW ID:700:ORDINAL:Primary::NATURE:CanPrecede:CWE ID:119:VIEW ID:1000:CHAIN ID:680::
<h5>WeaknessOrdinalities</h5>null
<h5>ApplicablePlatforms</h5>:::LANGUAGE CLASS:Language-Independent:LANGUAGE PREVALENCE:Undetermined::
<h5>BackgroundDetails</h5>null
<h5>AlternateTerms</h5>null
<h5>ModesOfIntroduction</h5>:::PHASE:Implementation:DESCRIPTION:::
<h5>ExploitationFactors</h5>null
<h5>LikelihoodofExploit</h5>null
<h5>CommonConsequences</h5>::SCOPE:Availability:TECHNICAL IMPACT:DoS: Crash, Exit, or Restart DoS: Resource Consumption (CPU) DoS: Resource Consumption (Memory) DoS: Instability:NOTE:Availability DoS: Crash, Exit, or Restart DoS: Resource Consumption (CPU) DoS: Resource Consumption (Memory) DoS: Instability This weakness will generally lead to undefined behavior and therefore crashes. In the case of overflows involving loop index variables, the likelihood of infinite loops is also high.::SCOPE:Integrity:TECHNICAL IMPACT:Modify Memory:NOTE:Integrity Modify Memory If the value in question is important to data (as opposed to flow), simple data corruption has occurred. Also, if the wrap around results in other conditions such as buffer overflows, further memory corruption may occur.::SCOPE:Confidentiality:SCOPE:Availability:SCOPE:Access Control:TECHNICAL IMPACT:Execute Unauthorized Code or Commands Bypass Protection Mechanism:NOTE:Confidentiality Availability Access Control Execute Unauthorized Code or Commands Bypass Protection Mechanism This weakness can sometimes trigger buffer overflows which can be used to execute arbitrary code. This is usually outside the scope of a program's implicit security policy.::
<h5>DetectionMethods</h5>::METHOD:Automated Static Analysis:EFFECTIVENESS:High:DESCRIPTION:This weakness can often be detected using automated static analysis tools. Many modern tools use data flow analysis or constraint-based techniques to minimize the number of false positives.::METHOD:Black Box:EFFECTIVENESS:Moderate:DESCRIPTION:Sometimes, evidence of this weakness can be detected using dynamic tools and techniques that interact with the software using large test suites with many diverse inputs, such as fuzz testing (fuzzing), robustness testing, and fault injection. The software's operation may slow down, but it should not become unstable, crash, or generate incorrect results.::METHOD:Manual Analysis:EFFECTIVENESS:High:DESCRIPTION:This weakness can be detected using tools and techniques that require manual (human) analysis, such as penetration testing, threat modeling, and interactive tools that allow the tester to record and modify an active session. Specifically, manual static analysis is useful for evaluating the correctness of allocation calculations. This can be useful for detecting overflow conditions (CWE-190) or similar weaknesses that might have serious security impacts on the program.::METHOD:Automated Static Analysis - Binary or Bytecode:EFFECTIVENESS:High:DESCRIPTION:According to SOAR, the following detection techniques may be useful: Highly cost effective: Bytecode Weakness Analysis - including disassembler + source code weakness analysis Binary Weakness Analysis - including disassembler + source code weakness analysis::METHOD:Dynamic Analysis with Manual Results Interpretation:EFFECTIVENESS:SOAR Partial:DESCRIPTION:According to SOAR, the following detection techniques may be useful: Cost effective for partial coverage: Fuzz Tester Framework-based Fuzzer::METHOD:Manual Static Analysis - Source Code:EFFECTIVENESS:SOAR Partial:DESCRIPTION:According to SOAR, the following detection techniques may be useful: Cost effective for partial coverage: Manual Source Code Review (not inspections)::METHOD:Automated Static Analysis - Source Code:EFFECTIVENESS:High:DESCRIPTION:According to SOAR, the following detection techniques may be useful: Highly cost effective: Source code Weakness Analyzer Context-configured Source Code Weakness Analyzer::METHOD:Architecture or Design Review:EFFECTIVENESS:High:DESCRIPTION:According to SOAR, the following detection techniques may be useful: Highly cost effective: Formal Methods / Correct-By-Construction Cost effective for partial coverage: Inspection (IEEE 1028 standard) (can apply to requirements, design, source code, etc.)::
<h5>PotentialMitigations</h5>::PHASE:Requirements:STRATEGY::EFFECTIVENESS::DESCRIPTION:Ensure that all protocols are strictly defined, such that all out-of-bounds behavior can be identified simply, and require strict conformance to the protocol.::PHASE:Requirements:STRATEGY:Language Selection:EFFECTIVENESS::DESCRIPTION:Use a language that does not allow this weakness to occur or provides constructs that make this weakness easier to avoid. If possible, choose a language or compiler that performs automatic bounds checking.::PHASE:Architecture and Design:STRATEGY:Libraries or Frameworks:EFFECTIVENESS::DESCRIPTION:Use a vetted library or framework that does not allow this weakness to occur or provides constructs that make this weakness easier to avoid. Use libraries or frameworks that make it easier to handle numbers without unexpected consequences. Examples include safe integer handling packages such as SafeInt (C++) or IntegerLib (C or C++). [REF-106]::PHASE:Implementation:STRATEGY:Input Validation:EFFECTIVENESS::DESCRIPTION:Perform input validation on any numeric input by ensuring that it is within the expected range. Enforce that the input meets both the minimum and maximum requirements for the expected range. Use unsigned integers where possible. This makes it easier to perform sanity checks for integer overflows. When signed integers are required, ensure that the range check includes minimum values as well as maximum values.::PHASE:Implementation:STRATEGY::EFFECTIVENESS::DESCRIPTION:Understand the programming language's underlying representation and how it interacts with numeric calculation (CWE-681). Pay close attention to byte size discrepancies, precision, signed/unsigned distinctions, truncation, conversion and casting between types, not-a-number calculations, and how the language handles numbers that are too large or too small for its underlying representation. [REF-7] Also be careful to account for 32-bit, 64-bit, and other potential differences that may affect the numeric representation.::PHASE:Architecture and Design:STRATEGY::EFFECTIVENESS::DESCRIPTION:For any security checks that are performed on the client side, ensure that these checks are duplicated on the server side, in order to avoid CWE-602. Attackers can bypass the client-side checks by modifying values after the checks have been performed, or by changing the client to remove the client-side checks entirely. Then, these modified values would be submitted to the server.::PHASE:Implementation:STRATEGY:Compilation or Build Hardening:EFFECTIVENESS::DESCRIPTION:Examine compiler warnings closely and eliminate problems with potential security implications, such as signed / unsigned mismatch in memory operations, or use of uninitialized variables. Even if the weakness is rarely exploitable, a single failure may lead to the compromise of the entire system.::
<h5>ObservedExamples</h5>::REFERENCE:CVE-2010-2753:DESCRIPTION:chain: integer overflow leads to use-after-free:LINK:https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2010-2753REFERENCE:CVE-2002-0391:DESCRIPTION:Integer overflow via a large number of arguments.:LINK:https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2002-0391REFERENCE:CVE-2002-0639:DESCRIPTION:Integer overflow in OpenSSH as listed in the demonstrative examples.:LINK:https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2002-0639REFERENCE:CVE-2005-1141:DESCRIPTION:Image with large width and height leads to integer overflow.:LINK:https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2005-1141REFERENCE:CVE-2005-0102:DESCRIPTION:Length value of -1 leads to allocation of 0 bytes and resultant heap overflow.:LINK:https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2005-0102REFERENCE:CVE-2004-2013:DESCRIPTION:Length value of -1 leads to allocation of 0 bytes and resultant heap overflow.:LINK:https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2004-2013REFERENCE:CVE-2017-1000121:DESCRIPTION:chain: unchecked message size metadata allows integer overflow (CWE-190) leading to buffer overflow (CWE-119).:LINK:https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2017-1000121
<h5>FunctionalAreas</h5>::Number ProcessingMemory ManagementCounters
<h5>AffectedResources</h5>null
<h5>TaxonomyMappings</h5>TAXONOMY NAME:PLOVER:ENTRY NAME:Integer overflow (wrap or wraparound)::::TAXONOMY NAME:7 Pernicious Kingdoms:ENTRY NAME:Integer Overflow::::TAXONOMY NAME:CLASP:ENTRY NAME:Integer overflow::::TAXONOMY NAME:CERT C Secure Coding:ENTRY ID:INT18-C:ENTRY NAME:Evaluate integer expressions in a larger size before comparing or assigning to that size:MAPPING FIT:CWE More Abstract::::TAXONOMY NAME:CERT C Secure Coding:ENTRY ID:INT30-C:ENTRY NAME:Ensure that unsigned integer operations do not wrap:MAPPING FIT:CWE More Abstract::::TAXONOMY NAME:CERT C Secure Coding:ENTRY ID:INT32-C:ENTRY NAME:Ensure that operations on signed integers do not result in overflow:MAPPING FIT:Imprecise::::TAXONOMY NAME:CERT C Secure Coding:ENTRY ID:INT35-C:ENTRY NAME:Evaluate integer expressions in a larger size before comparing or assigning to that size::::TAXONOMY NAME:CERT C Secure Coding:ENTRY ID:MEM07-C:ENTRY NAME:Ensure that the arguments to calloc(), when multiplied, do not wrap:MAPPING FIT:CWE More Abstract::::TAXONOMY NAME:CERT C Secure Coding:ENTRY ID:MEM35-C:ENTRY NAME:Allocate sufficient memory for an object::::TAXONOMY NAME:WASC:ENTRY ID:3:ENTRY NAME:Integer Overflows::::TAXONOMY NAME:Software Fault Patterns:ENTRY ID:SFP1:ENTRY NAME:Glitch in computation::
<h5>RelatedAttackPatterns</h5>::92::
<h5>Notes</h5>TYPE:Relationship:NOTE:Integer overflows can be primary to buffer overflows.::::TYPE:Terminology:NOTE:Integer overflow is sometimes used to cover several types of errors, including signedness errors, or buffer overflows that involve manipulation of integer data types instead of characters. Part of the confusion results from the fact that 0xffffffff is -1 in a signed context. Other confusion also arises because of the role that integer overflows have in chains.::

