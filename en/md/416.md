# ID: 416 - Use After Free
<h5>Name</h5>Use After Free
<h5>Weakness</h5>Base
<h5>Status</h5>Draft
<h5>Description</h5>Referencing memory after it has been freed can cause a program to crash, use unexpected values, or execute code.
<h5>ExtendedDescription</h5>The use of previously-freed memory can have any number of adverse consequences, ranging from the corruption of valid data to the execution of arbitrary code, depending on the instantiation and timing of the flaw. The simplest way data corruption may occur involves the system's reuse of the freed memory. Use-after-free errors have two common and sometimes overlapping causes: Error conditions and other exceptional circumstances. Confusion over which part of the program is responsible for freeing the memory. In this scenario, the memory in question is allocated to another pointer validly at some point after it has been freed. The original pointer to the freed memory is used again and points to somewhere within the new allocation. As the data is changed, it corrupts the validly used memory; this induces undefined behavior in the process. If the newly allocated data chances to hold a class, in C++ for example, various function pointers may be scattered within the heap data. If one of these function pointers is overwritten with an address to valid shellcode, execution of arbitrary code can be achieved.
<h5>RelatedWeaknesses</h5>::NATURE:ChildOf:CWE ID:825:VIEW ID:1000:ORDINAL:Primary::NATURE:CanPrecede:CWE ID:120:VIEW ID:1000::NATURE:CanPrecede:CWE ID:123:VIEW ID:1000::
<h5>WeaknessOrdinalities</h5>null
<h5>ApplicablePlatforms</h5>::LANGUAGE NAME:C:LANGUAGE PREVALENCE:Undetermined::LANGUAGE NAME:C++:LANGUAGE PREVALENCE:Undetermined::
<h5>BackgroundDetails</h5>null
<h5>AlternateTerms</h5>::TERM:Dangling pointer:DESCRIPTION:::TERM:Use-After-Free:DESCRIPTION:::
<h5>ModesOfIntroduction</h5>:::PHASE:Architecture and Design:DESCRIPTION::::PHASE:Implementation:DESCRIPTION:::
<h5>ExploitationFactors</h5>null
<h5>LikelihoodofExploit</h5>null
<h5>CommonConsequences</h5>::SCOPE:Integrity:TECHNICAL IMPACT:Modify Memory:NOTE:Integrity Modify Memory The use of previously freed memory may corrupt valid data, if the memory area in question has been allocated and used properly elsewhere.::SCOPE:Availability:TECHNICAL IMPACT:DoS: Crash, Exit, or Restart:NOTE:Availability DoS: Crash, Exit, or Restart If chunk consolidation occurs after the use of previously freed data, the process may crash when invalid data is used as chunk information.::SCOPE:Integrity:SCOPE:Confidentiality:SCOPE:Availability:TECHNICAL IMPACT:Execute Unauthorized Code or Commands:NOTE:Integrity Confidentiality Availability Execute Unauthorized Code or Commands If malicious data is entered before chunk consolidation can take place, it may be possible to take advantage of a write-what-where primitive to execute arbitrary code.::
<h5>DetectionMethods</h5>null
<h5>PotentialMitigations</h5>::PHASE:Architecture and Design:STRATEGY::EFFECTIVENESS::DESCRIPTION:Choose a language that provides automatic memory management.::PHASE:Implementation:STRATEGY::EFFECTIVENESS::DESCRIPTION:When freeing pointers, be sure to set them to NULL once they are freed. However, the utilization of multiple or complex data structures may lower the usefulness of this strategy.::
<h5>ObservedExamples</h5>::REFERENCE:CVE-2010-4168:DESCRIPTION:Use-after-free triggered by closing a connection while data is still being transmitted.:LINK:https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2010-4168REFERENCE:CVE-2010-2941:DESCRIPTION:Improper allocation for invalid data leads to use-after-free.:LINK:https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2010-2941REFERENCE:CVE-2010-2547:DESCRIPTION:certificate with a large number of Subject Alternate Names not properly handled in realloc, leading to use-after-free:LINK:https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2010-2547REFERENCE:CVE-2010-1772:DESCRIPTION:Timers are not disabled when a related object is deleted:LINK:https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2010-1772REFERENCE:CVE-2010-1437:DESCRIPTION:Access to a dead object that is being cleaned up:LINK:https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2010-1437REFERENCE:CVE-2010-1208:DESCRIPTION:object is deleted even with a non-zero reference count, and later accessed:LINK:https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2010-1208REFERENCE:CVE-2010-0629:DESCRIPTION:use-after-free involving request containing an invalid version number:LINK:https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2010-0629REFERENCE:CVE-2010-0378:DESCRIPTION:unload of an object that is currently being accessed by other functionality:LINK:https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2010-0378REFERENCE:CVE-2010-0302:DESCRIPTION:incorrectly tracking a reference count leads to use-after-free:LINK:https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2010-0302REFERENCE:CVE-2010-0249:DESCRIPTION:use-after-free related to use of uninitialized memory:LINK:https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2010-0249REFERENCE:CVE-2010-0050:DESCRIPTION:HTML document with incorrectly-nested tags:LINK:https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2010-0050REFERENCE:CVE-2009-3658:DESCRIPTION:Use after free in ActiveX object by providing a malformed argument to a method:LINK:https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2009-3658REFERENCE:CVE-2009-3616:DESCRIPTION:use-after-free by disconnecting during data transfer, or a message containing incorrect data types:LINK:https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2009-3616REFERENCE:CVE-2009-3553:DESCRIPTION:disconnect during a large data transfer causes incorrect reference count, leading to use-after-free:LINK:https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2009-3553REFERENCE:CVE-2009-2416:DESCRIPTION:use-after-free found by fuzzing:LINK:https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2009-2416REFERENCE:CVE-2009-1837:DESCRIPTION:Chain: race condition (CWE-362) from improper handling of a page transition in web client while an applet is loading (CWE-368) leads to use after free (CWE-416):LINK:https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2009-1837REFERENCE:CVE-2009-0749:DESCRIPTION:realloc generates new buffer and pointer, but previous pointer is still retained, leading to use after free:LINK:https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2009-0749REFERENCE:CVE-2010-3328:DESCRIPTION:Use-after-free in web browser, probably resultant from not initializing memory.:LINK:https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2010-3328REFERENCE:CVE-2008-5038:DESCRIPTION:use-after-free when one thread accessed memory that was freed by another thread:LINK:https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2008-5038REFERENCE:CVE-2008-0077:DESCRIPTION:assignment of malformed values to certain properties triggers use after free:LINK:https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2008-0077REFERENCE:CVE-2006-4434:DESCRIPTION:mail server does not properly handle a long header.:LINK:https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2006-4434REFERENCE:CVE-2010-2753:DESCRIPTION:chain: integer overflow leads to use-after-free:LINK:https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2010-2753REFERENCE:CVE-2006-4997:DESCRIPTION:freed pointer dereference:LINK:https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2006-4997
<h5>FunctionalAreas</h5>null
<h5>AffectedResources</h5>Memory::
<h5>TaxonomyMappings</h5>TAXONOMY NAME:7 Pernicious Kingdoms:ENTRY NAME:Use After Free::::TAXONOMY NAME:CLASP:ENTRY NAME:Using freed memory::::TAXONOMY NAME:CERT C Secure Coding:ENTRY ID:MEM00-C:ENTRY NAME:Allocate and free memory in the same module, at the same level of abstraction::::TAXONOMY NAME:CERT C Secure Coding:ENTRY ID:MEM01-C:ENTRY NAME:Store a new value in pointers immediately after free()::::TAXONOMY NAME:CERT C Secure Coding:ENTRY ID:MEM30-C:ENTRY NAME:Do not access freed memory:MAPPING FIT:Exact::::TAXONOMY NAME:Software Fault Patterns:ENTRY ID:SFP15:ENTRY NAME:Faulty Resource Use::
<h5>RelatedAttackPatterns</h5>null
<h5>Notes</h5>null

