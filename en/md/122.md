# ID: 122 - Heap-based Buffer Overflow
<h5>Name</h5>Heap-based Buffer Overflow
<h5>Weakness</h5>Variant
<h5>Status</h5>Draft
<h5>Description</h5>A heap overflow condition is a buffer overflow, where the buffer that can be overwritten is allocated in the heap portion of memory, generally meaning that the buffer was allocated using a routine such as malloc().
<h5>ExtendedDescription</h5>null
<h5>RelatedWeaknesses</h5>::NATURE:ChildOf:CWE ID:788:VIEW ID:1000:ORDINAL:Primary::NATURE:ChildOf:CWE ID:788:VIEW ID:699:ORDINAL:Primary::NATURE:ChildOf:CWE ID:787:VIEW ID:1000::NATURE:ChildOf:CWE ID:787:VIEW ID:699::
<h5>WeaknessOrdinalities</h5>::ORDINALITY:Primary:DESCRIPTION:::
<h5>ApplicablePlatforms</h5>::LANGUAGE NAME:C:LANGUAGE PREVALENCE:Undetermined::LANGUAGE NAME:C++:LANGUAGE PREVALENCE:Undetermined::
<h5>BackgroundDetails</h5>null
<h5>AlternateTerms</h5>null
<h5>ModesOfIntroduction</h5>:::PHASE:Architecture and Design:DESCRIPTION::::PHASE:Implementation:DESCRIPTION:::
<h5>ExploitationFactors</h5>null
<h5>LikelihoodofExploit</h5>null
<h5>CommonConsequences</h5>::SCOPE:Availability:TECHNICAL IMPACT:DoS: Crash, Exit, or Restart DoS: Resource Consumption (CPU) DoS: Resource Consumption (Memory):NOTE:Availability DoS: Crash, Exit, or Restart DoS: Resource Consumption (CPU) DoS: Resource Consumption (Memory) Buffer overflows generally lead to crashes. Other attacks leading to lack of availability are possible, including putting the program into an infinite loop.::SCOPE:Integrity:SCOPE:Confidentiality:SCOPE:Availability:SCOPE:Access Control:TECHNICAL IMPACT:Execute Unauthorized Code or Commands Bypass Protection Mechanism Modify Memory:NOTE:Integrity Confidentiality Availability Access Control Execute Unauthorized Code or Commands Bypass Protection Mechanism Modify Memory Buffer overflows often can be used to execute arbitrary code, which is usually outside the scope of a program's implicit security policy. Besides important user data, heap-based overflows can be used to overwrite function pointers that may be living in memory, pointing it to the attacker's code. Even in applications that do not explicitly use function pointers, the run-time will usually leave many in memory. For example, object methods in C++ are generally implemented using function pointers. Even in C programs, there is often a global offset table used by the underlying runtime.::SCOPE:Integrity:SCOPE:Confidentiality:SCOPE:Availability:SCOPE:Access Control:SCOPE:Other:TECHNICAL IMPACT:Execute Unauthorized Code or Commands Bypass Protection Mechanism Other:NOTE:Integrity Confidentiality Availability Access Control Other Execute Unauthorized Code or Commands Bypass Protection Mechanism Other When the consequence is arbitrary code execution, this can often be used to subvert any other security service.::
<h5>DetectionMethods</h5>null
<h5>PotentialMitigations</h5>::PHASE::STRATEGY::EFFECTIVENESS::DESCRIPTION:Pre-design: Use a language or compiler that performs automatic bounds checking.::PHASE:Architecture and Design:STRATEGY::EFFECTIVENESS::DESCRIPTION:Use an abstraction library to abstract away risky APIs. Not a complete solution.::PHASE:Build and Compilation:STRATEGY::EFFECTIVENESS::DESCRIPTION:Pre-design through Build: Canary style bounds checking, library changes which ensure the validity of chunk data, and other such fixes are possible, but should not be relied upon.::PHASE:Implementation:STRATEGY::EFFECTIVENESS::DESCRIPTION:Implement and perform bounds checking on input.::PHASE:Implementation:STRATEGY:Libraries or Frameworks:EFFECTIVENESS::DESCRIPTION:Do not use dangerous functions such as gets. Look for their safe equivalent, which checks for the boundary.::PHASE:Operation:STRATEGY::EFFECTIVENESS::DESCRIPTION:Use OS-level preventative functionality. This is not a complete solution, but it provides some defense in depth.::
<h5>ObservedExamples</h5>::REFERENCE:CVE-2007-4268:DESCRIPTION:Chain: integer signedness error (CWE-195) passes signed comparison, leading to heap overflow (CWE-122):LINK:https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2007-4268REFERENCE:CVE-2009-2523:DESCRIPTION:Chain: product does not handle when an input string is not NULL terminated (CWE-170), leading to buffer over-read (CWE-125) or heap-based buffer overflow (CWE-122).:LINK:https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2009-2523
<h5>FunctionalAreas</h5>null
<h5>AffectedResources</h5>Memory::
<h5>TaxonomyMappings</h5>TAXONOMY NAME:CLASP:ENTRY NAME:Heap overflow::::TAXONOMY NAME:Software Fault Patterns:ENTRY ID:SFP8:ENTRY NAME:Faulty Buffer Access::::TAXONOMY NAME:CERT C Secure Coding:ENTRY ID:STR31-C:ENTRY NAME:Guarantee that storage for strings has sufficient space for character data and the null terminator:MAPPING FIT:CWE More Specific::
<h5>RelatedAttackPatterns</h5>::92::
<h5>Notes</h5>TYPE:Relationship:NOTE:Heap-based buffer overflows are usually just as dangerous as stack-based buffer overflows.::

