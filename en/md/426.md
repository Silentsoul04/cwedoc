# ID: 426 - Untrusted Search Path
<h5>Name</h5>Untrusted Search Path
<h5>Weakness</h5>Base
<h5>Status</h5>Draft
<h5>Description</h5>The application searches for critical resources using an externally-supplied search path that can point to resources that are not under the application's direct control.
<h5>ExtendedDescription</h5>This might allow attackers to execute their own programs, access unauthorized data files, or modify configuration in unexpected ways. If the application uses a search path to locate critical resources such as programs, then an attacker could modify that search path to point to a malicious program, which the targeted application would then execute. The problem extends to any type of critical resource that the application trusts. Some of the most common variants of untrusted search path are: In various UNIX and Linux-based systems, the PATH environment variable may be consulted to locate executable programs, and LD_PRELOAD may be used to locate a separate library. In various Microsoft-based systems, the PATH environment variable is consulted to locate a DLL, if the DLL is not found in other paths that appear earlier in the search order.
<h5>RelatedWeaknesses</h5>::NATURE:ChildOf:CWE ID:642:VIEW ID:1000:ORDINAL:Primary::NATURE:ChildOf:CWE ID:673:VIEW ID:1000::NATURE:PeerOf:CWE ID:427:VIEW ID:1000::NATURE:PeerOf:CWE ID:428:VIEW ID:1000::
<h5>WeaknessOrdinalities</h5>null
<h5>ApplicablePlatforms</h5>:::LANGUAGE CLASS:Language-Independent:LANGUAGE PREVALENCE:Undetermined:::OPERATING SYSTEM CLASS:OS-Independent:OPERATING SYSTEM PREVALENCE:Undetermined::
<h5>BackgroundDetails</h5>null
<h5>AlternateTerms</h5>::TERM:Untrusted Path:DESCRIPTION:::
<h5>ModesOfIntroduction</h5>:::PHASE:Architecture and Design:DESCRIPTION::::PHASE:Implementation:DESCRIPTION:::
<h5>ExploitationFactors</h5>null
<h5>LikelihoodofExploit</h5>null
<h5>CommonConsequences</h5>::SCOPE:Integrity:SCOPE:Confidentiality:SCOPE:Availability:SCOPE:Access Control:TECHNICAL IMPACT:Gain Privileges or Assume Identity Execute Unauthorized Code or Commands:NOTE:Integrity Confidentiality Availability Access Control Gain Privileges or Assume Identity Execute Unauthorized Code or Commands There is the potential for arbitrary code execution with privileges of the vulnerable program.::SCOPE:Availability:TECHNICAL IMPACT:DoS: Crash, Exit, or Restart:NOTE:Availability DoS: Crash, Exit, or Restart The program could be redirected to the wrong files, potentially triggering a crash or hang when the targeted file is too large or does not have the expected format.::SCOPE:Confidentiality:TECHNICAL IMPACT:Read Files or Directories:NOTE:Confidentiality Read Files or Directories The program could send the output of unauthorized files to the attacker.::
<h5>DetectionMethods</h5>::METHOD:Black Box:EFFECTIVENESS::DESCRIPTION:Use monitoring tools that examine the software's process as it interacts with the operating system and the network. This technique is useful in cases when source code is unavailable, if the software was not developed by you, or if you want to verify that the build phase did not introduce any new weaknesses. Examples include debuggers that directly attach to the running process; system-call tracing utilities such as truss (Solaris) and strace (Linux); system activity monitors such as FileMon, RegMon, Process Monitor, and other Sysinternals utilities (Windows); and sniffers and protocol analyzers that monitor network traffic. Attach the monitor to the process and look for library functions and system calls that suggest when a search path is being used. One pattern is when the program performs multiple accesses of the same file but in different directories, with repeated failures until the proper filename is found. Library calls such as getenv() or their equivalent can be checked to see if any path-related variables are being accessed.::METHOD:Automated Static Analysis:EFFECTIVENESS::DESCRIPTION:Use automated static analysis tools that target this type of weakness. Many modern techniques use data flow analysis to minimize the number of false positives. This is not a perfect solution, since 100% accuracy and coverage are not feasible.::METHOD:Manual Analysis:EFFECTIVENESS::DESCRIPTION:Use tools and techniques that require manual (human) analysis, such as penetration testing, threat modeling, and interactive tools that allow the tester to record and modify an active session. These may be more effective than strictly automated techniques. This is especially the case with weaknesses that are related to design and business rules.::
<h5>PotentialMitigations</h5>::PHASE:Architecture and Design Implementation:STRATEGY:Attack Surface Reduction:EFFECTIVENESS::DESCRIPTION:Hard-code the search path to a set of known-safe values (such as system directories), or only allow them to be specified by the administrator in a configuration file. Do not allow these settings to be modified by an external party. Be careful to avoid related weaknesses such as CWE-426 and CWE-428.::PHASE:Implementation:STRATEGY::EFFECTIVENESS::DESCRIPTION:When invoking other programs, specify those programs using fully-qualified pathnames. While this is an effective approach, code that uses fully-qualified pathnames might not be portable to other systems that do not use the same pathnames. The portability can be improved by locating the full-qualified paths in a centralized, easily-modifiable location within the source code, and having the code refer to these paths.::PHASE:Implementation:STRATEGY::EFFECTIVENESS::DESCRIPTION:Remove or restrict all environment settings before invoking other programs. This includes the PATH environment variable, LD_LIBRARY_PATH, and other settings that identify the location of code libraries, and any application-specific search paths.::PHASE:Implementation:STRATEGY::EFFECTIVENESS::DESCRIPTION:Check your search path before use and remove any elements that are likely to be unsafe, such as the current working directory or a temporary files directory.::PHASE:Implementation:STRATEGY::EFFECTIVENESS::DESCRIPTION:Use other functions that require explicit paths. Making use of any of the other readily available functions that require explicit paths is a safe way to avoid this problem. For example, system() in C does not require a full path since the shell can take care of it, while execl() and execv() require a full path.::
<h5>ObservedExamples</h5>::REFERENCE:CVE-1999-1120:DESCRIPTION:Application relies on its PATH environment variable to find and execute program.:LINK:https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-1999-1120REFERENCE:CVE-2008-1810:DESCRIPTION:Database application relies on its PATH environment variable to find and execute program.:LINK:https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2008-1810REFERENCE:CVE-2007-2027:DESCRIPTION:Chain: untrusted search path enabling resultant format string by loading malicious internationalization messages.:LINK:https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2007-2027REFERENCE:CVE-2008-3485:DESCRIPTION:Untrusted search path using malicious .EXE in Windows environment.:LINK:https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2008-3485REFERENCE:CVE-2008-2613:DESCRIPTION:setuid program allows compromise using path that finds and loads a malicious library.:LINK:https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2008-2613REFERENCE:CVE-2008-1319:DESCRIPTION:Server allows client to specify the search path, which can be modified to point to a program that the client has uploaded.:LINK:https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2008-1319
<h5>FunctionalAreas</h5>::Program InvocationCode Libraries
<h5>AffectedResources</h5>System Process::
<h5>TaxonomyMappings</h5>TAXONOMY NAME:PLOVER:ENTRY NAME:Untrusted Search Path::::TAXONOMY NAME:CLASP:ENTRY NAME:Relative path library search::::TAXONOMY NAME:CERT C Secure Coding:ENTRY ID:ENV03-C:ENTRY NAME:Sanitize the environment when invoking external programs::
<h5>RelatedAttackPatterns</h5>::38::
<h5>Notes</h5>TYPE:Research Gap:NOTE:Search path issues on Windows are under-studied and possibly under-reported.::

