# ID: 805 - Buffer Access with Incorrect Length Value
<h5>Name</h5>Buffer Access with Incorrect Length Value
<h5>Weakness</h5>Base
<h5>Status</h5>Incomplete
<h5>Description</h5>The software uses a sequential operation to read or write a buffer, but it uses an incorrect length value that causes it to access memory that is outside of the bounds of the buffer.
<h5>ExtendedDescription</h5>When the length value exceeds the size of the destination, a buffer overflow could occur.
<h5>RelatedWeaknesses</h5>::NATURE:ChildOf:CWE ID:119:VIEW ID:1000:ORDINAL:Primary::NATURE:ChildOf:CWE ID:119:VIEW ID:699:ORDINAL:Primary::
<h5>WeaknessOrdinalities</h5>::ORDINALITY:Resultant:DESCRIPTION:::ORDINALITY:Primary:DESCRIPTION:::
<h5>ApplicablePlatforms</h5>::LANGUAGE NAME:C:LANGUAGE PREVALENCE:Often::LANGUAGE NAME:C++:LANGUAGE PREVALENCE:Often:::LANGUAGE CLASS:Assembly:LANGUAGE PREVALENCE:Undetermined::
<h5>BackgroundDetails</h5>null
<h5>AlternateTerms</h5>null
<h5>ModesOfIntroduction</h5>:::PHASE:Implementation:DESCRIPTION:::
<h5>ExploitationFactors</h5>null
<h5>LikelihoodofExploit</h5>null
<h5>CommonConsequences</h5>::SCOPE:Integrity:SCOPE:Confidentiality:SCOPE:Availability:TECHNICAL IMPACT:Execute Unauthorized Code or Commands:NOTE:Integrity Confidentiality Availability Execute Unauthorized Code or Commands Buffer overflows often can be used to execute arbitrary code, which is usually outside the scope of a program's implicit security policy. This can often be used to subvert any other security service.::SCOPE:Availability:TECHNICAL IMPACT:DoS: Crash, Exit, or Restart DoS: Resource Consumption (CPU):NOTE:Availability DoS: Crash, Exit, or Restart DoS: Resource Consumption (CPU) Buffer overflows generally lead to crashes. Other attacks leading to lack of availability are possible, including putting the program into an infinite loop.::
<h5>DetectionMethods</h5>::METHOD:Automated Static Analysis:EFFECTIVENESS:High:DESCRIPTION:This weakness can often be detected using automated static analysis tools. Many modern tools use data flow analysis or constraint-based techniques to minimize the number of false positives. Automated static analysis generally does not account for environmental considerations when reporting out-of-bounds memory operations. This can make it difficult for users to determine which warnings should be investigated first. For example, an analysis tool might report buffer overflows that originate from command line arguments in a program that is not expected to run with setuid or other special privileges.::METHOD:Automated Dynamic Analysis:EFFECTIVENESS:Moderate:DESCRIPTION:This weakness can be detected using dynamic tools and techniques that interact with the software using large test suites with many diverse inputs, such as fuzz testing (fuzzing), robustness testing, and fault injection. The software's operation may slow down, but it should not become unstable, crash, or generate incorrect results.::METHOD:Manual Analysis:EFFECTIVENESS::DESCRIPTION:Manual analysis can be useful for finding this weakness, but it might not achieve desired code coverage within limited time constraints. This becomes difficult for weaknesses that must be considered for all inputs, since the attack surface can be too large.::
<h5>PotentialMitigations</h5>::PHASE:Requirements:STRATEGY:Language Selection:EFFECTIVENESS::DESCRIPTION:Use a language that does not allow this weakness to occur or provides constructs that make this weakness easier to avoid. For example, many languages that perform their own memory management, such as Java and Perl, are not subject to buffer overflows. Other languages, such as Ada and C#, typically provide overflow protection, but the protection can be disabled by the programmer. Be wary that a language's interface to native code may still be subject to overflows, even if the language itself is theoretically safe.::PHASE:Architecture and Design:STRATEGY:Libraries or Frameworks:EFFECTIVENESS::DESCRIPTION:Use a vetted library or framework that does not allow this weakness to occur or provides constructs that make this weakness easier to avoid. Examples include the Safe C String Library (SafeStr) by Messier and Viega [REF-57], and the Strsafe.h library from Microsoft [REF-56]. These libraries provide safer versions of overflow-prone string-handling functions.::PHASE:Build and Compilation:STRATEGY:Compilation or Build Hardening:EFFECTIVENESS:Defense in Depth:DESCRIPTION:Run or compile the software using features or extensions that automatically provide a protection mechanism that mitigates or eliminates buffer overflows. For example, certain compilers and extensions provide automatic buffer overflow detection mechanisms that are built into the compiled code. Examples include the Microsoft Visual Studio /GS flag, Fedora/Red Hat FORTIFY_SOURCE GCC flag, StackGuard, and ProPolice.::PHASE:Implementation:STRATEGY::EFFECTIVENESS::DESCRIPTION:Consider adhering to the following rules when allocating and managing an application's memory: Double check that your buffer is as large as you specify. When using functions that accept a number of bytes to copy, such as strncpy(), be aware that if the destination buffer size is equal to the source buffer size, it may not NULL-terminate the string. Check buffer boundaries if accessing the buffer in a loop and make sure you are not in danger of writing past the allocated space. If necessary, truncate all input strings to a reasonable length before passing them to the copy and concatenation functions.::PHASE:Architecture and Design:STRATEGY::EFFECTIVENESS::DESCRIPTION:For any security checks that are performed on the client side, ensure that these checks are duplicated on the server side, in order to avoid CWE-602. Attackers can bypass the client-side checks by modifying values after the checks have been performed, or by changing the client to remove the client-side checks entirely. Then, these modified values would be submitted to the server.::PHASE:Operation:STRATEGY:Environment Hardening:EFFECTIVENESS:Defense in Depth:DESCRIPTION:Run or compile the software using features or extensions that randomly arrange the positions of a program's executable and libraries in memory. Because this makes the addresses unpredictable, it can prevent an attacker from reliably jumping to exploitable code. Examples include Address Space Layout Randomization (ASLR) [REF-58] [REF-60] and Position-Independent Executables (PIE) [REF-64].::PHASE:Operation:STRATEGY:Environment Hardening:EFFECTIVENESS:Defense in Depth:DESCRIPTION:Use a CPU and operating system that offers Data Execution Protection (NX) or its equivalent [REF-59] [REF-57].::PHASE:Architecture and Design Operation:STRATEGY:Environment Hardening:EFFECTIVENESS::DESCRIPTION:Run your code using the lowest privileges that are required to accomplish the necessary tasks [REF-76]. If possible, create isolated accounts with limited privileges that are only used for a single task. That way, a successful attack will not immediately give the attacker access to the rest of the software or its environment. For example, database applications rarely need to run as the database administrator, especially in day-to-day operations.::PHASE:Architecture and Design Operation:STRATEGY:Sandbox or Jail:EFFECTIVENESS:Limited:DESCRIPTION:Run the code in a jail or similar sandbox environment that enforces strict boundaries between the process and the operating system. This may effectively restrict which files can be accessed in a particular directory or which commands can be executed by the software. OS-level examples include the Unix chroot jail, AppArmor, and SELinux. In general, managed code may provide some protection. For example, java.io.FilePermission in the Java SecurityManager allows the software to specify restrictions on file operations. This may not be a feasible solution, and it only limits the impact to the operating system; the rest of the application may still be subject to compromise. Be careful to avoid CWE-243 and other weaknesses related to jails.::
<h5>ObservedExamples</h5>::REFERENCE:CVE-2011-1959:DESCRIPTION:Chain: large length value causes buffer over-read (CWE-126):LINK:https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2011-1959REFERENCE:CVE-2011-1848:DESCRIPTION:Use of packet length field to make a calculation, then copy into a fixed-size buffer:LINK:https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2011-1848REFERENCE:CVE-2011-0105:DESCRIPTION:Chain: retrieval of length value from an uninitialized memory location:LINK:https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2011-0105REFERENCE:CVE-2011-0606:DESCRIPTION:Crafted length value in document reader leads to buffer overflow:LINK:https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2011-0606REFERENCE:CVE-2011-0651:DESCRIPTION:SSL server overflow when the sum of multiple length fields exceeds a given value:LINK:https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2011-0651REFERENCE:CVE-2010-4156:DESCRIPTION:Language interpreter API function doesn't validate length argument, leading to information exposure:LINK:https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2010-4156
<h5>FunctionalAreas</h5>null
<h5>AffectedResources</h5>Memory::
<h5>TaxonomyMappings</h5>TAXONOMY NAME:CERT C Secure Coding:ENTRY ID:ARR38-C:ENTRY NAME:Guarantee that library functions do not form invalid pointers:MAPPING FIT:Imprecise::
<h5>RelatedAttackPatterns</h5>::100::
<h5>Notes</h5>null

