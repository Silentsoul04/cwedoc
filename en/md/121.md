# ID: 121 - Stack-based Buffer Overflow
<h5>Name</h5>Stack-based Buffer Overflow
<h5>Weakness</h5>Variant
<h5>Status</h5>Draft
<h5>Description</h5>A stack-based buffer overflow condition is a condition where the buffer being overwritten is allocated on the stack (i.e., is a local variable or, rarely, a parameter to a function).
<h5>ExtendedDescription</h5>null
<h5>RelatedWeaknesses</h5>::NATURE:ChildOf:CWE ID:788:VIEW ID:1000:ORDINAL:Primary::NATURE:ChildOf:CWE ID:788:VIEW ID:699:ORDINAL:Primary::NATURE:ChildOf:CWE ID:787:VIEW ID:1000::NATURE:ChildOf:CWE ID:787:VIEW ID:699::
<h5>WeaknessOrdinalities</h5>::ORDINALITY:Primary:DESCRIPTION:::
<h5>ApplicablePlatforms</h5>::LANGUAGE NAME:C:LANGUAGE PREVALENCE:Undetermined::LANGUAGE NAME:C++:LANGUAGE PREVALENCE:Undetermined::
<h5>BackgroundDetails</h5>::There are generally several security-critical data on an execution stack that can lead to arbitrary code execution. The most prominent is the stored return address, the memory address at which execution should continue once the current function is finished executing. The attacker can overwrite this value with some memory address to which the attacker also has write access, into which they place arbitrary code to be run with the full privileges of the vulnerable program. Alternately, the attacker can supply the address of an important call, for instance the POSIX system() call, leaving arguments to the call on the stack. This is often called a return into libc exploit, since the attacker generally forces the program to jump at return time into an interesting routine in the C standard library (libc). Other important data commonly on the stack include the stack pointer and frame pointer, two values that indicate offsets for computing memory addresses. Modifying those values can often be leveraged into a write-what-where condition.::
<h5>AlternateTerms</h5>::TERM:Stack Overflow:DESCRIPTION:Stack Overflow is often used to mean the same thing as stack-based buffer overflow, however it is also used on occasion to mean stack exhaustion, usually a result from an excessively recursive function call. Due to the ambiguity of the term, use of stack overflow to describe either circumstance is discouraged.::
<h5>ModesOfIntroduction</h5>:::PHASE:Architecture and Design:DESCRIPTION::::PHASE:Implementation:DESCRIPTION:::
<h5>ExploitationFactors</h5>null
<h5>LikelihoodofExploit</h5>null
<h5>CommonConsequences</h5>::SCOPE:Availability:TECHNICAL IMPACT:DoS: Crash, Exit, or Restart DoS: Resource Consumption (CPU) DoS: Resource Consumption (Memory):NOTE:Availability DoS: Crash, Exit, or Restart DoS: Resource Consumption (CPU) DoS: Resource Consumption (Memory) Buffer overflows generally lead to crashes. Other attacks leading to lack of availability are possible, including putting the program into an infinite loop.::SCOPE:Integrity:SCOPE:Confidentiality:SCOPE:Availability:SCOPE:Access Control:TECHNICAL IMPACT:Execute Unauthorized Code or Commands Bypass Protection Mechanism:NOTE:Integrity Confidentiality Availability Access Control Execute Unauthorized Code or Commands Bypass Protection Mechanism Buffer overflows often can be used to execute arbitrary code, which is usually outside the scope of a program's implicit security policy.::SCOPE:Integrity:SCOPE:Confidentiality:SCOPE:Availability:SCOPE:Access Control:SCOPE:Other:TECHNICAL IMPACT:Execute Unauthorized Code or Commands Bypass Protection Mechanism Other:NOTE:Integrity Confidentiality Availability Access Control Other Execute Unauthorized Code or Commands Bypass Protection Mechanism Other When the consequence is arbitrary code execution, this can often be used to subvert any other security service.::
<h5>DetectionMethods</h5>null
<h5>PotentialMitigations</h5>::PHASE:Build and Compilation:STRATEGY:Compilation or Build Hardening:EFFECTIVENESS:Defense in Depth:DESCRIPTION:Run or compile the software using features or extensions that automatically provide a protection mechanism that mitigates or eliminates buffer overflows. For example, certain compilers and extensions provide automatic buffer overflow detection mechanisms that are built into the compiled code. Examples include the Microsoft Visual Studio /GS flag, Fedora/Red Hat FORTIFY_SOURCE GCC flag, StackGuard, and ProPolice.::PHASE:Architecture and Design:STRATEGY::EFFECTIVENESS::DESCRIPTION:Use an abstraction library to abstract away risky APIs. Not a complete solution.::PHASE:Build and Compilation:STRATEGY::EFFECTIVENESS::DESCRIPTION:Compiler-based canary mechanisms such as StackGuard, ProPolice and the Microsoft Visual Studio /GS flag. Unless this provides automatic bounds checking, it is not a complete solution.::PHASE:Implementation:STRATEGY::EFFECTIVENESS::DESCRIPTION:Implement and perform bounds checking on input.::PHASE:Implementation:STRATEGY::EFFECTIVENESS::DESCRIPTION:Do not use dangerous functions such as gets. Use safer, equivalent functions which check for boundary errors.::PHASE:Operation:STRATEGY::EFFECTIVENESS::DESCRIPTION:Use OS-level preventative functionality, such as ASLR. This is not a complete solution.::
<h5>ObservedExamples</h5>null
<h5>FunctionalAreas</h5>null
<h5>AffectedResources</h5>null
<h5>TaxonomyMappings</h5>TAXONOMY NAME:CLASP:ENTRY NAME:Stack overflow::::TAXONOMY NAME:Software Fault Patterns:ENTRY ID:SFP8:ENTRY NAME:Faulty Buffer Access::::TAXONOMY NAME:CERT C Secure Coding:ENTRY ID:ARR38-C:ENTRY NAME:Guarantee that library functions do not form invalid pointers:MAPPING FIT:Imprecise::::TAXONOMY NAME:CERT C Secure Coding:ENTRY ID:STR31-C:ENTRY NAME:Guarantee that storage for strings has sufficient space for character data and the null terminator:MAPPING FIT:CWE More Specific::
<h5>RelatedAttackPatterns</h5>null
<h5>Notes</h5>TYPE:Other:NOTE:Stack-based buffer overflows can instantiate in return address overwrites, stack pointer overwrites or frame pointer overwrites. They can also be considered function pointer overwrites, array indexer overwrites or write-what-where condition, etc.::

