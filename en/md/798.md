# ID: 798 - Use of Hard-coded Credentials
<h5>Name</h5>Use of Hard-coded Credentials
<h5>Weakness</h5>Base
<h5>Status</h5>Incomplete
<h5>Description</h5>The software contains hard-coded credentials, such as a password or cryptographic key, which it uses for its own inbound authentication, outbound communication to external components, or encryption of internal data.
<h5>ExtendedDescription</h5>Hard-coded credentials typically create a significant hole that allows an attacker to bypass the authentication that has been configured by the software administrator. This hole might be difficult for the system administrator to detect. Even if detected, it can be difficult to fix, so the administrator may be forced into disabling the product entirely. There are two main variations: Inbound: the software contains an authentication mechanism that checks the input credentials against a hard-coded set of credentials. Outbound: the software connects to another system or component, and it contains hard-coded credentials for connecting to that component. In the Inbound variant, a default administration account is created, and a simple password is hard-coded into the product and associated with that account. This hard-coded password is the same for each installation of the product, and it usually cannot be changed or disabled by system administrators without manually modifying the program, or otherwise patching the software. If the password is ever discovered or published (a common occurrence on the Internet), then anybody with knowledge of this password can access the product. Finally, since all installations of the software will have the same password, even across different organizations, this enables massive attacks such as worms to take place. The Outbound variant applies to front-end systems that authenticate with a back-end service. The back-end service may require a fixed password which can be easily discovered. The programmer may simply hard-code those back-end credentials into the front-end software. Any user of that program may be able to extract the password. Client-side systems with hard-coded passwords pose even more of a threat, since the extraction of a password from a binary is usually very simple.
<h5>RelatedWeaknesses</h5>::NATURE:ChildOf:CWE ID:287:VIEW ID:1000:ORDINAL:Primary::NATURE:ChildOf:CWE ID:344:VIEW ID:1000::NATURE:ChildOf:CWE ID:671:VIEW ID:1000::NATURE:PeerOf:CWE ID:257:VIEW ID:1000::
<h5>WeaknessOrdinalities</h5>::ORDINALITY:Primary:DESCRIPTION:::
<h5>ApplicablePlatforms</h5>:::LANGUAGE CLASS:Language-Independent:LANGUAGE PREVALENCE:Undetermined::PARADIGN NAME:Mobile:PARADIGN PREVALENCE:Undetermined::
<h5>BackgroundDetails</h5>null
<h5>AlternateTerms</h5>null
<h5>ModesOfIntroduction</h5>:::PHASE:Architecture and Design:DESCRIPTION:::
<h5>ExploitationFactors</h5>null
<h5>LikelihoodofExploit</h5>null
<h5>CommonConsequences</h5>::SCOPE:Access Control:TECHNICAL IMPACT:Bypass Protection Mechanism:NOTE:Access Control Bypass Protection Mechanism If hard-coded passwords are used, it is almost certain that malicious users will gain access to the account in question.::SCOPE:Integrity:SCOPE:Confidentiality:SCOPE:Availability:SCOPE:Access Control:SCOPE:Other:TECHNICAL IMPACT:Read Application Data Gain Privileges or Assume Identity Execute Unauthorized Code or Commands Other:NOTE:Integrity Confidentiality Availability Access Control Other Read Application Data Gain Privileges or Assume Identity Execute Unauthorized Code or Commands Other This weakness can lead to the exposure of resources or functionality to unintended actors, possibly providing attackers with sensitive information or even execute arbitrary code.::
<h5>DetectionMethods</h5>::METHOD:Black Box:EFFECTIVENESS:Moderate:DESCRIPTION:Credential storage in configuration files is findable using black box methods, but the use of hard-coded credentials for an incoming authentication routine typically involves an account that is not visible outside of the code.::METHOD:Automated Static Analysis:EFFECTIVENESS::DESCRIPTION:Automated white box techniques have been published for detecting hard-coded credentials for incoming authentication, but there is some expert disagreement regarding their effectiveness and applicability to a broad range of methods.::METHOD:Manual Static Analysis:EFFECTIVENESS::DESCRIPTION:This weakness may be detectable using manual code analysis. Unless authentication is decentralized and applied throughout the software, there can be sufficient time for the analyst to find incoming authentication routines and examine the program logic looking for usage of hard-coded credentials. Configuration files could also be analyzed.::METHOD:Manual Dynamic Analysis:EFFECTIVENESS::DESCRIPTION:For hard-coded credentials in incoming authentication: use monitoring tools that examine the software's process as it interacts with the operating system and the network. This technique is useful in cases when source code is unavailable, if the software was not developed by you, or if you want to verify that the build phase did not introduce any new weaknesses. Examples include debuggers that directly attach to the running process; system-call tracing utilities such as truss (Solaris) and strace (Linux); system activity monitors such as FileMon, RegMon, Process Monitor, and other Sysinternals utilities (Windows); and sniffers and protocol analyzers that monitor network traffic. Attach the monitor to the process and perform a login. Using call trees or similar artifacts from the output, examine the associated behaviors and see if any of them appear to be comparing the input to a fixed string or value.::METHOD:Automated Static Analysis - Binary or Bytecode:EFFECTIVENESS:SOAR Partial:DESCRIPTION:According to SOAR, the following detection techniques may be useful: Cost effective for partial coverage: Bytecode Weakness Analysis - including disassembler + source code weakness analysis Binary Weakness Analysis - including disassembler + source code weakness analysis::METHOD:Manual Static Analysis - Binary or Bytecode:EFFECTIVENESS:High:DESCRIPTION:According to SOAR, the following detection techniques may be useful: Highly cost effective: Binary / Bytecode disassembler - then use manual analysis for vulnerabilities & anomalies::METHOD:Dynamic Analysis with Manual Results Interpretation:EFFECTIVENESS:SOAR Partial:DESCRIPTION:According to SOAR, the following detection techniques may be useful: Cost effective for partial coverage: Network Sniffer Forced Path Execution::METHOD:Manual Static Analysis - Source Code:EFFECTIVENESS:High:DESCRIPTION:According to SOAR, the following detection techniques may be useful: Highly cost effective: Focused Manual Spotcheck - Focused manual analysis of source Manual Source Code Review (not inspections)::METHOD:Automated Static Analysis - Source Code:EFFECTIVENESS:High:DESCRIPTION:According to SOAR, the following detection techniques may be useful: Highly cost effective: Source code Weakness Analyzer Context-configured Source Code Weakness Analyzer::METHOD:Automated Static Analysis:EFFECTIVENESS:SOAR Partial:DESCRIPTION:According to SOAR, the following detection techniques may be useful: Cost effective for partial coverage: Configuration Checker::METHOD:Architecture or Design Review:EFFECTIVENESS:High:DESCRIPTION:According to SOAR, the following detection techniques may be useful: Highly cost effective: Inspection (IEEE 1028 standard) (can apply to requirements, design, source code, etc.) Formal Methods / Correct-By-Construction::
<h5>PotentialMitigations</h5>::PHASE:Architecture and Design:STRATEGY::EFFECTIVENESS::DESCRIPTION:For outbound authentication: store passwords, keys, and other credentials outside of the code in a strongly-protected, encrypted configuration file or database that is protected from access by all outsiders, including other local users on the same system. Properly protect the key (CWE-320). If you cannot use encryption to protect the file, then make sure that the permissions are as restrictive as possible [REF-7]. In Windows environments, the Encrypted File System (EFS) may provide some protection.::PHASE:Architecture and Design:STRATEGY::EFFECTIVENESS::DESCRIPTION:For inbound authentication: Rather than hard-code a default username and password, key, or other authentication credentials for first time logins, utilize a first login mode that requires the user to enter a unique strong password or key.::PHASE:Architecture and Design:STRATEGY::EFFECTIVENESS::DESCRIPTION:If the software must contain hard-coded credentials or they cannot be removed, perform access control checks and limit which entities can access the feature that requires the hard-coded credentials. For example, a feature might only be enabled through the system console instead of through a network connection.::PHASE:Architecture and Design:STRATEGY::EFFECTIVENESS::DESCRIPTION:For inbound authentication using passwords: apply strong one-way hashes to passwords and store those hashes in a configuration file or database with appropriate access control. That way, theft of the file/database still requires the attacker to try to crack the password. When handling an incoming password during authentication, take the hash of the password and compare it to the saved hash. Use randomly assigned salts for each separate hash that is generated. This increases the amount of computation that an attacker needs to conduct a brute-force attack, possibly limiting the effectiveness of the rainbow table method.::PHASE:Architecture and Design:STRATEGY::EFFECTIVENESS::DESCRIPTION:For front-end to back-end connections: Three solutions are possible, although none are complete. The first suggestion involves the use of generated passwords or keys that are changed automatically and must be entered at given time intervals by a system administrator. These passwords will be held in memory and only be valid for the time intervals. Next, the passwords or keys should be limited at the back end to only performing actions valid for the front end, as opposed to having full access. Finally, the messages sent should be tagged and checksummed with time sensitive values so as to prevent replay-style attacks.::
<h5>ObservedExamples</h5>::REFERENCE:CVE-2010-2772:DESCRIPTION:SCADA system uses a hard-coded password to protect back-end database containing authorization information, exploited by Stuxnet worm:LINK:https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2010-2772REFERENCE:CVE-2010-2073:DESCRIPTION:FTP server library uses hard-coded usernames and passwords for three default accounts:LINK:https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2010-2073REFERENCE:CVE-2010-1573:DESCRIPTION:Chain: Router firmware uses hard-coded username and password for access to debug functionality, which can be used to execute arbitrary code:LINK:https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2010-1573REFERENCE:CVE-2008-2369:DESCRIPTION:Server uses hard-coded authentication key:LINK:https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2008-2369REFERENCE:CVE-2008-0961:DESCRIPTION:Backup product uses hard-coded username and password, allowing attackers to bypass authentication via the RPC interface:LINK:https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2008-0961REFERENCE:CVE-2008-1160:DESCRIPTION:Security appliance uses hard-coded password allowing attackers to gain root access:LINK:https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2008-1160REFERENCE:CVE-2006-7142:DESCRIPTION:Drive encryption product stores hard-coded cryptographic keys for encrypted configuration files in executable programs:LINK:https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2006-7142REFERENCE:CVE-2005-3716:DESCRIPTION:VoIP product uses unchangeable hard-coded public credentials that cannot be changed, which allows attackers to obtain sensitive information:LINK:https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2005-3716REFERENCE:CVE-2005-3803:DESCRIPTION:VoIP product uses hard coded public and private SNMP community strings that cannot be changed, which allows remote attackers to obtain sensitive information:LINK:https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2005-3803REFERENCE:CVE-2005-0496:DESCRIPTION:Backup product contains hard-coded credentials that effectively serve as a back door, which allows remote attackers to access the file system:LINK:https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2005-0496
<h5>FunctionalAreas</h5>null
<h5>AffectedResources</h5>null
<h5>TaxonomyMappings</h5>TAXONOMY NAME:CERT Java Secure Coding:ENTRY ID:MSC03-J:ENTRY NAME:Never hard code sensitive information::
<h5>RelatedAttackPatterns</h5>::190::191::70::
<h5>Notes</h5>null

