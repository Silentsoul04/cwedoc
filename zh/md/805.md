# ID: 805 - 长度值不正确的缓冲区访问
<h5>名称</h5>长度值不正确的缓冲区访问
<h5>弱点抽象</h5>底座
<h5>状态</h5>不完全
<h5>描述</h5>该软件使用顺序操作来读取或写入缓冲区，但它使用的长度值不正确，导致它访问超出缓冲区边界的内存。
<h5>扩展描述</h5>当长度值超过目标的大小时，可能会发生缓冲区溢出。
<h5>相关的弱点</h5>*性质：子女：CWE ID：119：视图ID：1000：序数：初级：自然：子女：CWE ID：119：视图ID：699：序号：主：
<h5>弱点规律</h5>：：ORDINALITY：Resultant：DESCRIPTION：ORDINALITY：Primary：DESCRIPTION：
<h5>适用的平台</h5>*语文名称：C：语文流行率：经常：语文名称：C+：语文流行率：语言类别：汇编：语文流行率：未定：
<h5>背景细节</h5>空
<h5>替代条款</h5>空
<h5>模式的介绍</h5>*阶段：执行：说明：
<h5>剥削因素</h5>空
<h5>利用的可能性</h5>空
<h5>常见的后果</h5>：：SCOPE：Integrity：SCOPE：Confidentiality：SCOPE：Availability：TECHNICAL影响：执行未经授权的代码或命令：注意：完整性机密性、可用性执行未经授权的代码或命令缓冲区溢出通常可用于执行任意代码，这通常超出了程序的隐式安全策略的范围。这通常用于颠覆任何其他安全服务。：范围：可用性：技术影响：DoS：崩溃、退出或重新启动DoS：资源消耗(CPU)：注意：可用性DoS：崩溃、退出或重新启动DoS：资源消耗(CPU)缓冲区溢出通常会导致崩溃。其他导致缺乏可用性的攻击是可能的，包括将程序放入一个无限循环中。：
<h5>检测方法</h5>*方法：自动静态分析：有效性：高：描述：这一弱点经常可以使用自动静态分析工具检测到。许多现代工具使用数据流分析或基于约束的技术来减少误报的数量。自动静态分析在报告超出范围的内存操作时通常不考虑环境因素.这会使用户很难确定应该首先调查哪些警告。例如，分析工具可能报告缓冲区溢出，这些溢出来自程序中的命令行参数，该程序不希望以setuid或其他特殊权限运行。：方法：可以使用动态工具和技术检测自动化的动态Analysis：EFFECTIVENESS：Moderate：DESCRIPTION：This弱点，这些工具和技术使用具有多种输入的大型测试套件与软件交互，例如模糊测试(模糊测试)、健壮性测试和故障注入。软件的操作可能会减慢，但不应变得不稳定、崩溃或产生不正确的结果。：方法：手动分析：有效性：描述：手动分析可能有助于发现此弱点，但它可能无法在有限的时间限制内实现所需的代码覆盖率。对于所有输入都必须考虑的弱点，这变得很困难，因为攻击面可能太大。
<h5>潜在的缓解措施</h5>::PHASE:Requirements:STRATEGY:Language Selection:EFFECTIVENESS::DESCRIPTION:Use a language that does not allow this weakness to occur or provides constructs that make this weakness easier to avoid. For example, many languages that perform their own memory management, such as Java and Perl, are not subject to buffer overflows. Other languages, such as Ada and C#, typically provide overflow protection, but the protection can be disabled by the programmer. Be wary that a language's interface to native code may still be subject to overflows, even if the language itself is theoretically safe.::PHASE:Architecture and Design:STRATEGY:Libraries or Frameworks:EFFECTIVENESS::DESCRIPTION:Use a vetted library or framework that does not allow this weakness to occur or provides constructs that make this weakness easier to avoid. Examples include the Safe C String Library (SafeStr) by Messier and Viega [REF-57], and the Strsafe.h library from Microsoft [REF-56]. These libraries provide safer versions of overflow-prone string-handling functions.::PHASE:Build and Compilation:STRATEGY:Compilation or Build Hardening:EFFECTIVENESS:Defense in Depth:DESCRIPTION:Run or compile the software using features or extensions that automatically provide a protection mechanism that mitigates or eliminates buffer overflows. For example, certain compilers and extensions provide automatic buffer overflow detection mechanisms that are built into the compiled code. Examples include the Microsoft Visual Studio /GS flag, Fedora/Red Hat FORTIFY_SOURCE GCC flag, StackGuard, and ProPolice.::PHASE:Implementation:STRATEGY::EFFECTIVENESS::DESCRIPTION:Consider adhering to the following rules when allocating and managing an application's memory: Double check that your buffer is as large as you specify. When using functions that accept a number of bytes to copy, such as strncpy(), be aware that if the destination buffer size is equal to the source buffer size, it may not NULL-terminate the string. Check buffer boundaries if accessing the buffer in a loop and make sure you are not in danger of writing past the allocated space. If necessary, truncate all input strings to a reasonable length before passing them to the copy and concatenation functions.::PHASE:Architecture and Design:STRATEGY::EFFECTIVENESS::DESCRIPTION:For any security checks that are performed on the client side, ensure that these checks are duplicated on the server side, in order to avoid CWE-602. Attackers can bypass the client-side checks by modifying values after the checks have been performed, or by changing the client to remove the client-side checks entirely. Then, these modified values would be submitted to the server.::PHASE:Operation:STRATEGY:Environment Hardening:EFFECTIVENESS:Defense in Depth:DESCRIPTION:Run or compile the software using features or extensions that randomly arrange the positions of a program's executable and libraries in memory. Because this makes the addresses unpredictable, it can prevent an attacker from reliably jumping to exploitable code. Examples include Address Space Layout Randomization (ASLR) [REF-58] [REF-60] and Position-Independent Executables (PIE) [REF-64].::PHASE:Operation:STRATEGY:Environment Hardening:EFFECTIVENESS:Defense in Depth:DESCRIPTION:Use a CPU and operating system that offers Data Execution Protection (NX) or its equivalent [REF-59] [REF-57].::PHASE:Architecture and Design Operation:STRATEGY:Environment Hardening:EFFECTIVENESS::DESCRIPTION:Run your code using the lowest privileges that are required to accomplish the necessary tasks [REF-76]. If possible, create isolated accounts with limited privileges that are only used for a single task. That way, a successful attack will not immediately give the attacker access to the rest of the software or its environment. For example, database applications rarely need to run as the database administrator, especially in day-to-day operations.::PHASE:Architecture and Design Operation:STRATEGY:Sandbox or Jail:EFFECTIVENESS:Limited:DESCRIPTION:Run the code in a jail or similar sandbox environment that enforces strict boundaries between the process and the operating system. This may effectively restrict which files can be accessed in a particular directory or which commands can be executed by the software. OS-level examples include the Unix chroot jail, AppArmor, and SELinux. In general, managed code may provide some protection. For example, java.io.FilePermission in the Java SecurityManager allows the software to specify restrictions on file operations. This may not be a feasible solution, and it only limits the impact to the operating system; the rest of the application may still be subject to compromise. Be careful to avoid CWE-243 and other weaknesses related to jails.::
<h5>观察到的例子</h5>：：REFERENCE：CVE-2011-1959：DESCRIPTION：Chain：large length value causes buffer over-read(CWE-126)：LINK：https：//cve.mitre.org/cgi-bin/cvename.cgi？name=CVE-2011-1959REFERENCE：CVE-2011-1848：DESCRIPTION：Use of packet length field to make a calculation，then copy into a fixed-size buffer：LINK：https：//cve.mitre.org/cgi-bin/cvename.cgi？name=CVE-2011-1848REFERENCE：CVE-2011-0105：DESCRIPTION：Chain：retrieval of length value from an uninitialized memory location：LINK：https：//cve.mitre.org/cgi-bin/cvename.cgi？name=CVE-2011-0105REFERENCE：CVE-2011-0606：DESCRIPTION：Crafted length value in document reader leads to buffer overflow：LINK：https：//cve.mitre.org/cgi-bin/cvename.cgi？name=CVE-2011-0606REFERENCE：CVE-2011-0651：DESCRIPTION：SSL server overflow when the sum of multiple length fields exceeds a given value：LINK：https：//cve.mitre.org/cgi-bin/cvename.cgi？name=CVE-2011-0651REFERENCE：CVE-2010-4156：DESCRIPTION：Language interpreter API function doesn‘t validate length argument，leading to information exposure：LINK：https：//cve.mitre.org/cgi-bin/cvename.cgi？name=CVE-2010-4156
<h5>功能区域</h5>空
<h5>影响资源</h5>记忆：
<h5>分类法映射</h5>分类法名称：CET C安全编码：条目ID：ARR 38-C：条目名称：保证库函数不会形成无效指针：映射适合：不精确：
<h5>相关的攻击模式</h5>*100：
<h5>笔记</h5>空

