# ID: 78 - OS命令中使用的特殊元素的不正确中和(“OS命令注入”)
<h5>名称</h5>OS命令中使用的特殊元素的不正确中和(“OS命令注入”)
<h5>弱点抽象</h5>底座
<h5>状态</h5>草案
<h5>描述</h5>该软件使用来自上游组件的受外部影响的输入来构造全部或部分OS命令，但它不会中和或错误地中和可能在发送到下游组件时修改预期OS命令的特殊元素。
<h5>扩展描述</h5>这可能允许攻击者直接在操作系统上执行意外的、危险的命令。此弱点可能导致攻击者无法直接访问操作系统(如Web应用程序)的环境中存在漏洞。或者，如果该漏洞发生在特权程序中，则允许攻击者指定通常无法访问的命令，或者使用攻击者没有的权限调用备用命令。如果受损进程不遵循最小权限原则，则问题会更加严重，因为攻击者控制的命令可能以特殊的系统权限运行，从而增加损坏的数量。OS命令注入至少有两种子类型：应用程序打算执行一个由自己控制的固定程序。它打算使用外部提供的输入作为该程序的参数。例如，程序可能使用系统(nslookup[hostname])运行nslookup，并允许用户提供主机名，该主机名用作参数。攻击者无法阻止nslookup执行。但是，如果程序不从主机名参数中删除命令分隔符，攻击者可以将分隔符放置到参数中，这允许他们在nslookup完成执行后执行自己的程序。应用程序接受一个输入，该输入用于完全选择要运行的程序以及要使用的命令。应用程序只需将整个命令重定向到操作系统。例如，程序可能使用exec([命令])执行用户提供的[命令]。如果该命令处于攻击者控制之下，则攻击者可以执行任意命令或程序。如果使用exec()和CreateProcess()等函数执行该命令，攻击者可能无法将多个命令合并到同一行中。从弱点的角度来看，这些变体代表了不同的程序员错误。在第一个变体中，程序员显然打算将来自不受信任方的输入作为要执行的命令中的参数的一部分。在第二个变体中，程序员不打算让任何不受信任的人可以访问该命令，但是程序员可能还没有考虑到恶意攻击者可以提供输入的其他方式。
<h5>相关的弱点</h5>*性质：子女：CWE ID：77：视图ID：1000：序数：初级：自然：子女：CWE ID：77：视图ID：699：序号：大自然：CWE ID：77：视图ID：1003：序数：大自然：CanAlsoBe：CWE ID：88：View ID：1000：
<h5>弱点规律</h5>空
<h5>适用的平台</h5>*语言类：语言-独立：语言普及率：未定：
<h5>背景细节</h5>空
<h5>替代条款</h5>*术语：外壳注入：说明：术语：shell元字符：描述：
<h5>模式的介绍</h5>*阶段：架构和Design：DESCRIPTION：PHASE：Implementation：DESCRIPTION：
<h5>剥削因素</h5>空
<h5>利用的可能性</h5>空
<h5>常见的后果</h5>：：SCOPE：Confidentiality：SCOPE：Integrity：SCOPE：Availability：SCOPE：Non-Repudiation：TECHNICAL IMPACT：Execute Unauthorized Code or Commands DoS：Crash，Exit，or Restart Read Files or Directories Modify Files or Directories Read Application Data Modify Application Data Hide Activities：NOTE：Confidentiality Integrity Availability Non-Repudiation Execute Unauthorized Code or Commands DoS：Crash，Exit，or Restart Read Files or Directories Modify Files or Directories Read Application Data Modify Application Data Hide Activities Attackers could execute unauthorized commands，which could then be used to disable the software，或者读取和修改攻击者没有直接访问权限的数据。由于目标应用程序直接执行命令，而不是攻击者，任何恶意活动都可能来自应用程序或应用程序的所有者。：
<h5>检测方法</h5>::METHOD:Automated Static Analysis:EFFECTIVENESS::DESCRIPTION:This weakness can often be detected using automated static analysis tools. Many modern tools use data flow analysis or constraint-based techniques to minimize the number of false positives. Automated static analysis might not be able to recognize when proper input validation is being performed, leading to false positives - i.e., warnings that do not have any security consequences or require any code changes. Automated static analysis might not be able to detect the usage of custom API functions or third-party libraries that indirectly invoke OS commands, leading to false negatives - especially if the API/library code is not available for analysis.::METHOD:Automated Dynamic Analysis:EFFECTIVENESS:Moderate:DESCRIPTION:This weakness can be detected using dynamic tools and techniques that interact with the software using large test suites with many diverse inputs, such as fuzz testing (fuzzing), robustness testing, and fault injection. The software's operation may slow down, but it should not become unstable, crash, or generate incorrect results.::METHOD:Manual Static Analysis:EFFECTIVENESS:High:DESCRIPTION:Since this weakness does not typically appear frequently within a single software package, manual white box techniques may be able to provide sufficient code coverage and reduction of false positives if all potentially-vulnerable operations can be assessed within limited time constraints.::METHOD:Automated Static Analysis - Binary or Bytecode:EFFECTIVENESS:High:DESCRIPTION:According to SOAR, the following detection techniques may be useful: Highly cost effective: Bytecode Weakness Analysis - including disassembler + source code weakness analysis Binary Weakness Analysis - including disassembler + source code weakness analysis::METHOD:Dynamic Analysis with Automated Results Interpretation:EFFECTIVENESS:SOAR Partial:DESCRIPTION:According to SOAR, the following detection techniques may be useful: Cost effective for partial coverage: Web Application Scanner Web Services Scanner Database Scanners::METHOD:Dynamic Analysis with Manual Results Interpretation:EFFECTIVENESS:SOAR Partial:DESCRIPTION:According to SOAR, the following detection techniques may be useful: Cost effective for partial coverage: Fuzz Tester Framework-based Fuzzer::METHOD:Manual Static Analysis - Source Code:EFFECTIVENESS:High:DESCRIPTION:According to SOAR, the following detection techniques may be useful: Highly cost effective: Manual Source Code Review (not inspections) Cost effective for partial coverage: Focused Manual Spotcheck - Focused manual analysis of source::METHOD:Automated Static Analysis - Source Code:EFFECTIVENESS:High:DESCRIPTION:According to SOAR, the following detection techniques may be useful: Highly cost effective: Source code Weakness Analyzer Context-configured Source Code Weakness Analyzer::METHOD:Architecture or Design Review:EFFECTIVENESS:High:DESCRIPTION:According to SOAR, the following detection techniques may be useful: Highly cost effective: Formal Methods / Correct-By-Construction Cost effective for partial coverage: Inspection (IEEE 1028 standard) (can apply to requirements, design, source code, etc.)::
<h5>潜在的缓解措施</h5>::PHASE:Architecture and Design:STRATEGY::EFFECTIVENESS::DESCRIPTION:If at all possible, use library calls rather than external processes to recreate the desired functionality.::PHASE:Architecture and Design Operation:STRATEGY:Sandbox or Jail:EFFECTIVENESS:Limited:DESCRIPTION:Run the code in a jail or similar sandbox environment that enforces strict boundaries between the process and the operating system. This may effectively restrict which files can be accessed in a particular directory or which commands can be executed by the software. OS-level examples include the Unix chroot jail, AppArmor, and SELinux. In general, managed code may provide some protection. For example, java.io.FilePermission in the Java SecurityManager allows the software to specify restrictions on file operations. This may not be a feasible solution, and it only limits the impact to the operating system; the rest of the application may still be subject to compromise. Be careful to avoid CWE-243 and other weaknesses related to jails.::PHASE:Architecture and Design:STRATEGY:Attack Surface Reduction:EFFECTIVENESS::DESCRIPTION:For any data that will be used to generate a command to be executed, keep as much of that data out of external control as possible. For example, in web applications, this may require storing the data locally in the session's state instead of sending it out to the client in a hidden form field.::PHASE:Architecture and Design:STRATEGY::EFFECTIVENESS::DESCRIPTION:For any security checks that are performed on the client side, ensure that these checks are duplicated on the server side, in order to avoid CWE-602. Attackers can bypass the client-side checks by modifying values after the checks have been performed, or by changing the client to remove the client-side checks entirely. Then, these modified values would be submitted to the server.::PHASE:Architecture and Design:STRATEGY:Libraries or Frameworks:EFFECTIVENESS::DESCRIPTION:Use a vetted library or framework that does not allow this weakness to occur or provides constructs that make this weakness easier to avoid. For example, consider using the ESAPI Encoding control [REF-45] or a similar tool, library, or framework. These will help the programmer encode outputs in a manner less prone to error.::PHASE:Implementation:STRATEGY:Output Encoding:EFFECTIVENESS::DESCRIPTION:While it is risky to use dynamically-generated query strings, code, or commands that mix control and data together, sometimes it may be unavoidable. Properly quote arguments and escape any special characters within those arguments. The most conservative approach is to escape or filter all characters that do not pass an extremely strict whitelist (such as everything that is not alphanumeric or white space). If some special characters are still needed, such as white space, wrap each argument in quotes after the escaping/filtering step. Be careful of argument injection (CWE-88).::PHASE:Implementation:STRATEGY::EFFECTIVENESS::DESCRIPTION:If the program to be executed allows arguments to be specified within an input file or from standard input, then consider using that mode to pass arguments instead of the command line.::PHASE:Architecture and Design:STRATEGY:Parameterization:EFFECTIVENESS::DESCRIPTION:If available, use structured mechanisms that automatically enforce the separation between data and code. These mechanisms may be able to provide the relevant quoting, encoding, and validation automatically, instead of relying on the developer to provide this capability at every point where output is generated. Some languages offer multiple functions that can be used to invoke commands. Where possible, identify any function that invokes a command shell using a single string, and replace it with a function that requires individual arguments. These functions typically perform appropriate quoting and filtering of arguments. For example, in C, the system() function accepts a string that contains the entire command to be executed, whereas execl(), execve(), and others require an array of strings, one for each argument. In Windows, CreateProcess() only accepts one command at a time. In Perl, if system() is provided with an array of arguments, then it will quote each of the arguments.::PHASE:Implementation:STRATEGY:Input Validation:EFFECTIVENESS::DESCRIPTION:Assume all input is malicious. Use an accept known good input validation strategy, i.e., use a whitelist of acceptable inputs that strictly conform to specifications. Reject any input that does not strictly conform to specifications, or transform it into something that does. When performing input validation, consider all potentially relevant properties, including length, type of input, the full range of acceptable values, missing or extra inputs, syntax, consistency across related fields, and conformance to business rules. As an example of business rule logic, boat may be syntactically valid because it only contains alphanumeric characters, but it is not valid if the input is only expected to contain colors such as red or blue. Do not rely exclusively on looking for malicious or malformed inputs (i.e., do not rely on a blacklist). A blacklist is likely to miss at least one undesirable input, especially if the code's environment changes. This can give attackers enough room to bypass the intended validation. However, blacklists can be useful for detecting potential attacks or determining which inputs are so malformed that they should be rejected outright. When constructing OS command strings, use stringent whitelists that limit the character set based on the expected value of the parameter in the request. This will indirectly limit the scope of an attack, but this technique is less important than proper output encoding and escaping. Note that proper output encoding, escaping, and quoting is the most effective solution for preventing OS command injection, although input validation may provide some defense-in-depth. This is because it effectively limits what will appear in output. Input validation will not always prevent OS command injection, especially if you are required to support free-form text fields that could contain arbitrary characters. For example, when invoking a mail program, you might need to allow the subject field to contain otherwise-dangerous inputs like ; and > characters, which would need to be escaped or otherwise handled. In this case, stripping the character might reduce the risk of OS command injection, but it would produce incorrect behavior because the subject field would not be recorded as the user intended. This might seem to be a minor inconvenience, but it could be more important when the program relies on well-structured subject lines in order to pass messages to other components. Even if you make a mistake in your validation (such as forgetting one out of 100 input fields), appropriate encoding is still likely to protect you from injection-based attacks. As long as it is not done in isolation, input validation is still a useful technique, since it may significantly reduce your attack surface, allow you to detect some attacks, and provide other security benefits that proper encoding does not address.::PHASE:Architecture and Design:STRATEGY:Enforcement by Conversion:EFFECTIVENESS::DESCRIPTION:When the set of acceptable objects, such as filenames or URLs, is limited or known, create a mapping from a set of fixed input values (such as numeric IDs) to the actual filenames or URLs, and reject all other inputs.::PHASE:Operation:STRATEGY:Compilation or Build Hardening:EFFECTIVENESS::DESCRIPTION:Run the code in an environment that performs automatic taint propagation and prevents any command execution that uses tainted variables, such as Perl's -T switch. This will force the program to perform validation steps that remove the taint, although you must be careful to correctly validate your inputs so that you do not accidentally mark dangerous inputs as untainted (see CWE-183 and CWE-184).::PHASE:Operation:STRATEGY:Environment Hardening:EFFECTIVENESS::DESCRIPTION:Run the code in an environment that performs automatic taint propagation and prevents any command execution that uses tainted variables, such as Perl's -T switch. This will force the program to perform validation steps that remove the taint, although you must be careful to correctly validate your inputs so that you do not accidentally mark dangerous inputs as untainted (see CWE-183 and CWE-184).::PHASE:Implementation:STRATEGY::EFFECTIVENESS::DESCRIPTION:Ensure that error messages only contain minimal details that are useful to the intended audience, and nobody else. The messages need to strike the balance between being too cryptic and not being cryptic enough. They should not necessarily reveal the methods that were used to determine the error. Such detailed information can be used to refine the original attack to increase the chances of success. If errors must be tracked in some detail, capture them in log messages - but consider what could occur if the log messages can be viewed by attackers. Avoid recording highly sensitive information such as passwords in any form. Avoid inconsistent messaging that might accidentally tip off an attacker about internal state, such as whether a username is valid or not. In the context of OS Command Injection, error information passed back to the user might reveal whether an OS command is being executed and possibly which command is being used.::PHASE:Operation:STRATEGY:Sandbox or Jail:EFFECTIVENESS::DESCRIPTION:Use runtime policy enforcement to create a whitelist of allowable commands, then prevent use of any command that does not appear in the whitelist. Technologies such as AppArmor are available to do this.::PHASE:Operation:STRATEGY:Firewall:EFFECTIVENESS:Moderate:DESCRIPTION:Use an application firewall that can detect attacks against this weakness. It can be beneficial in cases in which the code cannot be fixed (because it is controlled by a third party), as an emergency prevention measure while more comprehensive software assurance measures are applied, or to provide defense in depth.::PHASE:Architecture and Design Operation:STRATEGY:Environment Hardening:EFFECTIVENESS::DESCRIPTION:Run your code using the lowest privileges that are required to accomplish the necessary tasks [REF-76]. If possible, create isolated accounts with limited privileges that are only used for a single task. That way, a successful attack will not immediately give the attacker access to the rest of the software or its environment. For example, database applications rarely need to run as the database administrator, especially in day-to-day operations.::PHASE:Operation Implementation:STRATEGY:Environment Hardening:EFFECTIVENESS::DESCRIPTION:When using PHP, configure the application so that it does not use register_globals. During implementation, develop the application so that it does not rely on this feature, but be wary of implementing a register_globals emulation that is subject to weaknesses such as CWE-95, CWE-621, and similar issues.::
<h5>观察到的例子</h5>：：REFERENCE：CVE-1999-0067：DESCRIPTION：Canonical例子。当调用电话簿program.：LINK：https：//cve.mitre.org/cgi-bin/cvename.cgi？name=CVE-1999-0067REFERENCE：CVE-2001-1246：DESCRIPTION：Language解释器的邮件函数时，CGI程序不会中和μ元字符，它接受另一个与危险的popen()调用中使用的字符串连接的参数。Since there is no neutralization of this argument，both OS Command Injection(CWE-78)and Argument Injection(CWE-88)are possible.：LINK：https：//cve.mitre.org/cgi-bin/cvename.cgi？name=CVE-2001-1246REFERENCE：CVE-2002-0061：DESCRIPTION：Web server allows command execution using|(pipe)character.：LINK：https：//cve.mitre.org/cgi-bin/cvename.cgi？name=CVE-2002-0061REFERENCE：CVE-2003-0041：DESCRIPTION：FTP client does not filter|from filenames returned by the server，allowing for OS command injection.：LINK：https：//cve.mitre.org/cgi-bin/cvename.cgi？name=CVE-2003-0041REFERENCE：CVE-2008-2575：DESCRIPTION：Shell metacharacters in a filename in a ZIP archive：LINK：https：//cve.mitre.org/cgi-bin/cvename.cgi？name=CVE-2008-2575REFERENCE：CVE-2002-1898：DESCRIPTION：Shell metacharacters in a telnet：//link are not properly handled when the launching application processes the link.：LINK：https：//cve.mitre.org/cgi-bin/cvename.cgi？name=CVE-2002-1898REFERENCE：CVE-2008-4304：DESCRIPTION：OS command injection throughenvironment variable.：LINK：https：//cve.mitre.org/cgi-bin/cvename.cgi？name=CVE-2008-4304REFERENCE：CVE-2008-4796：DESCRIPTION：OS command injection through https：//URLs：LINK：https：//cve.mitre.org/cgi-bin/cvename.cgi？name=CVE-2008-4796REFERENCE：CVE-2007-3572：DESCRIPTION：Chain：incomplete blacklist for OS command injection：LINK：https：//cve.mitre.org/cgi-bin/cvename.cgi？name=CVE-2007-3572REFERENCE：CVE-2012-1988：DESCRIPTION：Product allows remote users to execute arbitrary commands by creating a file whose pathname contains shell metacharacters.：LINK：https：//cve.mitre.org/cgi-bin/cvename.cgi？name=CVE-2012-1988
<h5>功能区域</h5>*程序调用
<h5>影响资源</h5>系统流程：
<h5>分类法映射</h5>TAXONOMY NAME：PLOVER：ENTRY NAME：OS Command Injection：TAXONOMY NAME：OWASP Top Ten 2007：ENTRY ID：A3：ENTRY NAME：Malicious File Execution：MAPPING FIT：CWE More Specific：TAXONOMY NAME：OWASP Top Ten 2004：ENTRY ID：A6：ENTRY NAME：Injection Flaws：MAPPING FIT：CWE More Specific：TAXONOMY NAME：CERT C Secure Coding：ENTRY ID：ENV03-C：ENTRY NAME：Sanitize the environment when invoking external programs：TAXONOMY NAME：CERT C Secure Coding：ENTRY ID：ENV33-C：ENTRY NAME：Do not call system()：MAPPING FIT：CWE More Specific：TAXONOMY NAME：CERT C Secure Coding：ENTRY ID：STR02-C：ENTRY NAME：Sanitize data passed to complex subsystems：TAXONOMY NAME：WASC：ENTRY ID：31：ENTRY NAME：OS Commanding：TAXONOMY NAME：CERT Java Secure Coding：ENTRY ID：IDS07-J：ENTRY名称：不要向Runtime.exec()方法传递不受信任的、未经清理的数据：分类法名称：SoftwareFaultPatterns：条目ID：SFP 24：条目名称：被污染的命令输入：
<h5>相关的攻击模式</h5>*108：15：43：6：88：
<h5>笔记</h5>类型：术语：注意：OS命令注入短语对不同的人有不同的含义。对于某些人来说，它只是指攻击者在被调用的应用程序控制程序的参数中注入命令分隔符的情况。对某些人来说，它指的是允许攻击者执行自己选择的OS命令的任何类型的攻击。这种使用可能包括不受信任的搜索路径缺陷(CWE-426)，这些弱点导致应用程序查找和执行攻击者控制的程序。当参数注入(CWE-88)允许将备用命令行开关或选项插入到命令行(例如-exec开关，其目的可能是将后续参数作为命令执行)(例如，UNIX find命令中存在此-exec开关)时，问题更加复杂。然而，在后一种情况下，CWE-88可以被视为CWE-78链中的主要弱点。：类型：研究差距：注：需要对OS命令注入变量之间的区别进行更多的调查，包括角色参数注入(CWE-88)。在其他与注入相关的问题(如SQL注入)中可能存在等效的区别。：

