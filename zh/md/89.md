# ID: 89 - SQL命令中使用的特殊元素的不正确中和(“SQL注入”)
<h5>名称</h5>SQL命令中使用的特殊元素的不正确中和(“SQL注入”)
<h5>弱点抽象</h5>底座
<h5>状态</h5>草案
<h5>描述</h5>该软件使用来自上游组件的受外部影响的输入来构造SQL命令的全部或部分，但它不会中和或错误地中和可能在发送到下游组件时修改预期SQL命令的特殊元素。
<h5>扩展描述</h5>在用户可控输入中，如果不充分删除或引用SQL语法，生成的SQL查询将导致这些输入被解释为SQL，而不是普通的用户数据。这可用于更改查询逻辑以绕过安全检查，或插入修改后端数据库的附加语句，可能包括执行系统命令。SQL注入已经成为数据库驱动网站的一个常见问题。该漏洞很容易被发现，并且很容易被利用，因此，任何站点或软件包，即使是最小的用户基础，都很可能受到这类攻击的攻击。此漏洞取决于这样一个事实，即SQL对控件和数据平面没有真正的区别。
<h5>相关的弱点</h5>*性质：子女：CWE ID：943：视图ID：1000：主：自然：子女：CWE ID：943：视图ID：699：主：自然：子女：943：视图ID：1003：主：
<h5>弱点规律</h5>空
<h5>适用的平台</h5>*语言类：语言独立：语言流行率：待定：技术名称：数据库服务器：技术流行率：未定：
<h5>背景细节</h5>空
<h5>替代条款</h5>空
<h5>模式的介绍</h5>*阶段：架构和Design：DESCRIPTION：PHASE：Implementation：DESCRIPTION：PHASE：Operation：DESCRIPTION：
<h5>剥削因素</h5>空
<h5>利用的可能性</h5>空
<h5>常见的后果</h5>：：SCOPE：Confidentiality：TECHNICAL IMPACT：Read Application Data：NOTE：Confidentiality Read Application Data Since SQL databases generally hold sensitive data，loss of confidentiality is a frequent problem with SQL injection vulnerabilities.：：SCOPE：Access Control：TECHNICAL IMPACT：Bypass Protection Mechanism：NOTE：Access Control Bypass Protection Mechanism If poor SQL commands are used to check user names and passwords，it may be possible to connect to a system as another user with no previous knowledge of the password.：：SCOPE：Access Control：TECHNICAL IMPACT：Bypass Protection Mechanism：NOTE：Access Control Bypass如果授权信息保存在SQL数据库中，则可以通过成功利用SQL注入漏洞更改此信息。：范围：完整性：技术影响：修改应用程序数据：注意：完整性修改应用程序数据，就像读取敏感信息一样，也可以通过SQL注入攻击更改或删除此信息：
<h5>检测方法</h5>*方法：自动静态分析：有效性：描述：这一弱点经常可以使用自动静态分析工具检测到。许多现代工具使用数据流分析或基于约束的技术来减少误报的数量。自动静态分析可能无法识别何时执行适当的输入验证，从而导致误报-即没有任何安全后果或不需要任何代码更改的警告。自动静态分析可能无法检测到间接调用sql命令的自定义api函数或第三方库的使用，从而导致假否定，特别是当api/库代码无法进行分析时。：方法：可以使用动态工具和技术来检测自动动态Analysis：EFFECTIVENESS：Moderate：DESCRIPTION：This弱点，这些工具和技术使用具有多种输入的大型测试套件与软件进行交互，例如模糊测试(Fuzze)、健壮性测试和故障注入。软件的操作可能会减慢，但不应变得不稳定、崩溃或产生不正确的结果。：方法：手动分析：有效性：描述：手动分析可能有助于发现此弱点，但它可能无法在有限的时间限制内实现所需的代码覆盖率。This becomes difficult for weaknesses that must be considered for all inputs，since the attack surface can be too large.：：METHOD：Automated Static Analysis-Binary or Bytecode：EFFECTIVENESS：High：DESCRIPTION：According to SOAR，the following detection techniques may be useful：Highly cost effective：Bytecode Weakness Analysis-including disassembler+source code weakness analysis Binary Weakness Analysis-including disassembler+source code weakness analysis：：METHOD：Dynamic Analysis with Automated Results Interpretation：EFFECTIVENESS：High：DESCRIPTION：According to SOAR，the following detectiontechniques may be useful：Highly cost effective：Database Scanners Cost effective for partial coverage：Web Application Scanner Web Services Scanner：：METHOD：Dynamic Analysis with Manual Results Interpretation：EFFECTIVENESS：SOAR Partial：DESCRIPTION：According to SOAR，the following detection techniques may be useful：Cost effective for partial coverage：Fuzz Tester Framework-based Fuzzer：：METHOD：Manual Static Analysis-Source Code：EFFECTIVENESS：High：DESCRIPTION：According to SOAR，the following detection techniques may be useful：Highly cost effective：Manual Source Code Review(not inspections)Cost effective forpartial coverage：Focused Manual Spotcheck-Focused manual analysis of source：：METHOD：Automated Static Analysis-Source Code：EFFECTIVENESS：High：DESCRIPTION：According to SOAR，the following detection techniques may be useful：Highly cost effective：Source code Weakness Analyzer Context-configured Source Code Weakness Analyzer：：METHOD：Architecture or Design Review：EFFECTIVENESS：High：DESCRIPTION：According to SOAR，the following detection techniques may be useful：Highly cost effective：Formal Methods/Correct-By-Construction Cost effective for partial coverage：Inspection(IEEE 1028 standard)(can apply to requirements，design，source code，etc.)：：
<h5>潜在的缓解措施</h5>::PHASE:Architecture and Design:STRATEGY:Libraries or Frameworks:EFFECTIVENESS::DESCRIPTION:Use a vetted library or framework that does not allow this weakness to occur or provides constructs that make this weakness easier to avoid. For example, consider using persistence layers such as Hibernate or Enterprise Java Beans, which can provide significant protection against SQL injection if used properly.::PHASE:Architecture and Design:STRATEGY:Parameterization:EFFECTIVENESS::DESCRIPTION:If available, use structured mechanisms that automatically enforce the separation between data and code. These mechanisms may be able to provide the relevant quoting, encoding, and validation automatically, instead of relying on the developer to provide this capability at every point where output is generated. Process SQL queries using prepared statements, parameterized queries, or stored procedures. These features should accept parameters or variables and support strong typing. Do not dynamically construct and execute query strings within these features using exec or similar functionality, since this may re-introduce the possibility of SQL injection. [REF-867]::PHASE:Architecture and Design Operation:STRATEGY:Environment Hardening:EFFECTIVENESS::DESCRIPTION:Run your code using the lowest privileges that are required to accomplish the necessary tasks [REF-76]. If possible, create isolated accounts with limited privileges that are only used for a single task. That way, a successful attack will not immediately give the attacker access to the rest of the software or its environment. For example, database applications rarely need to run as the database administrator, especially in day-to-day operations. Specifically, follow the principle of least privilege when creating user accounts to a SQL database. The database users should only have the minimum privileges necessary to use their account. If the requirements of the system indicate that a user can read and modify their own data, then limit their privileges so they cannot read/write others' data. Use the strictest permissions possible on all database objects, such as execute-only for stored procedures.::PHASE:Architecture and Design:STRATEGY::EFFECTIVENESS::DESCRIPTION:For any security checks that are performed on the client side, ensure that these checks are duplicated on the server side, in order to avoid CWE-602. Attackers can bypass the client-side checks by modifying values after the checks have been performed, or by changing the client to remove the client-side checks entirely. Then, these modified values would be submitted to the server.::PHASE:Implementation:STRATEGY:Output Encoding:EFFECTIVENESS::DESCRIPTION:While it is risky to use dynamically-generated query strings, code, or commands that mix control and data together, sometimes it may be unavoidable. Properly quote arguments and escape any special characters within those arguments. The most conservative approach is to escape or filter all characters that do not pass an extremely strict whitelist (such as everything that is not alphanumeric or white space). If some special characters are still needed, such as white space, wrap each argument in quotes after the escaping/filtering step. Be careful of argument injection (CWE-88). Instead of building a new implementation, such features may be available in the database or programming language. For example, the Oracle DBMS_ASSERT package can check or enforce that parameters have certain properties that make them less vulnerable to SQL injection. For MySQL, the mysql_real_escape_string() API function is available in both C and PHP.::PHASE:Implementation:STRATEGY:Input Validation:EFFECTIVENESS::DESCRIPTION:Assume all input is malicious. Use an accept known good input validation strategy, i.e., use a whitelist of acceptable inputs that strictly conform to specifications. Reject any input that does not strictly conform to specifications, or transform it into something that does. When performing input validation, consider all potentially relevant properties, including length, type of input, the full range of acceptable values, missing or extra inputs, syntax, consistency across related fields, and conformance to business rules. As an example of business rule logic, boat may be syntactically valid because it only contains alphanumeric characters, but it is not valid if the input is only expected to contain colors such as red or blue. Do not rely exclusively on looking for malicious or malformed inputs (i.e., do not rely on a blacklist). A blacklist is likely to miss at least one undesirable input, especially if the code's environment changes. This can give attackers enough room to bypass the intended validation. However, blacklists can be useful for detecting potential attacks or determining which inputs are so malformed that they should be rejected outright. When constructing SQL query strings, use stringent whitelists that limit the character set based on the expected value of the parameter in the request. This will indirectly limit the scope of an attack, but this technique is less important than proper output encoding and escaping. Note that proper output encoding, escaping, and quoting is the most effective solution for preventing SQL injection, although input validation may provide some defense-in-depth. This is because it effectively limits what will appear in output. Input validation will not always prevent SQL injection, especially if you are required to support free-form text fields that could contain arbitrary characters. For example, the name O'Reilly would likely pass the validation step, since it is a common last name in the English language. However, it cannot be directly inserted into the database because it contains the ' apostrophe character, which would need to be escaped or otherwise handled. In this case, stripping the apostrophe might reduce the risk of SQL injection, but it would produce incorrect behavior because the wrong name would be recorded. When feasible, it may be safest to disallow meta-characters entirely, instead of escaping them. This will provide some defense in depth. After the data is entered into the database, later processes may neglect to escape meta-characters before use, and you may not have control over those processes.::PHASE:Architecture and Design:STRATEGY:Enforcement by Conversion:EFFECTIVENESS::DESCRIPTION:When the set of acceptable objects, such as filenames or URLs, is limited or known, create a mapping from a set of fixed input values (such as numeric IDs) to the actual filenames or URLs, and reject all other inputs.::PHASE:Implementation:STRATEGY::EFFECTIVENESS::DESCRIPTION:Ensure that error messages only contain minimal details that are useful to the intended audience, and nobody else. The messages need to strike the balance between being too cryptic and not being cryptic enough. They should not necessarily reveal the methods that were used to determine the error. Such detailed information can be used to refine the original attack to increase the chances of success. If errors must be tracked in some detail, capture them in log messages - but consider what could occur if the log messages can be viewed by attackers. Avoid recording highly sensitive information such as passwords in any form. Avoid inconsistent messaging that might accidentally tip off an attacker about internal state, such as whether a username is valid or not. In the context of SQL Injection, error messages revealing the structure of a SQL query can help attackers tailor successful attack strings.::PHASE:Operation:STRATEGY:Firewall:EFFECTIVENESS:Moderate:DESCRIPTION:Use an application firewall that can detect attacks against this weakness. It can be beneficial in cases in which the code cannot be fixed (because it is controlled by a third party), as an emergency prevention measure while more comprehensive software assurance measures are applied, or to provide defense in depth.::PHASE:Operation Implementation:STRATEGY:Environment Hardening:EFFECTIVENESS::DESCRIPTION:When using PHP, configure the application so that it does not use register_globals. During implementation, develop the application so that it does not rely on this feature, but be wary of implementing a register_globals emulation that is subject to weaknesses such as CWE-95, CWE-621, and similar issues.::
<h5>观察到的例子</h5>：：REFERENCE：CVE-2004-0366：DESCRIPTION：chain：SQL injection in library intended for database authentication allows SQL injection and authentication bypass.：LINK：https：//cve.mitre.org/cgi-bin/cvename.cgi？name=CVE-2004-0366REFERENCE：CVE-2008-2790：DESCRIPTION：SQL injection through an ID that was supposed to be numeric.：LINK：https：//cve.mitre.org/cgi-bin/cvename.cgi？name=CVE-2008-2790REFERENCE：CVE-2008-2223：DESCRIPTION：SQL injection through an ID that was supposed to be numeric.：LINK：https：//cve.mitre.org/cgi-bin/cvename.cgi？name=CVE-2008-2223REFERENCE：CVE-2007-6602：DESCRIPTION：SQL injection via user name.：LINK：https：//cve.mitre.org/cgi-bin/cvename.cgi？name=CVE-2007-6602REFERENCE：CVE-2008-5817：DESCRIPTION：SQL injection via user name or password fields.：LINK：https：//cve.mitre.org/cgi-bin/cvename.cgi？name=CVE-2008-5817REFERENCE：CVE-2003-0377：DESCRIPTION：SQL injection in security product，using a crafted group name.：LINK：https：//cve.mitre.org/cgi-bin/cvename.cgi？name=CVE-2003-0377REFERENCE：CVE-2008-2380：DESCRIPTION：SQL injection in authentication library.：LINK：https：//cve.mitre.org/cgi-bin/cvename.cgi？name=CVE-2008-2380REFERENCE：CVE-2017-11508：DESCRIPTION：SQL injection in vulnerability management and reporting tool，using a crafted password.：LINK：https：//cve.mitre.org/cgi-bin/cvename.cgi？name=CVE-2017-11508
<h5>功能区域</h5>空
<h5>影响资源</h5>空
<h5>分类法映射</h5>TAXONOMY NAME：PLOVER：ENTRY NAME：SQL injection：TAXONOMY NAME：7 Pernicious Kingdoms：ENTRY NAME：SQL Injection：TAXONOMY NAME：CLASP：ENTRY NAME：SQL injection：TAXONOMY NAME：OWASP Top Ten 2007：ENTRY ID：A2：ENTRY NAME：Injection Flaws：MAPPING FIT：CWE More Specific：TAXONOMY NAME：OWASP Top Ten 2004：ENTRY ID：A1：ENTRY NAME：Unvalidated Input：MAPPING FIT：CWE More Specific：TAXONOMY NAME：OWASP Top Ten 2004：ENTRY ID：A6：ENTRY NAME：Injection Flaws：MAPPING FIT：CWE More Specific：TAXONOMY NAME：WASC：ENTRY ID：19：ENTRY NAME：SQL Injection：TAXONOMY NAME：Software Fault Patterns：ENTRY ID：SFP24：ENTRY NAME：Tainted input to command：：
<h5>相关的攻击模式</h5>*108：109：110：470：66：7：
<h5>笔记</h5>类型：关系：注意：SQL注入可能是由特殊字符管理不善、女佣或黑名单/白名单问题造成的。它可能是身份验证错误的主要原因。：

