# ID: 20 - 不正确的输入验证
<h5>名称</h5>不正确的输入验证
<h5>弱点抽象</h5>班级，等级
<h5>状态</h5>可用
<h5>描述</h5>产品不会验证或错误验证可能影响程序的控制流或数据流的输入。
<h5>扩展描述</h5>当软件无法正确验证输入时，攻击者就能够以应用程序其他部分不期望的形式完成输入。这将导致系统部分接收意外输入，这可能导致更改控制流、资源的任意控制或任意代码执行。
<h5>相关的弱点</h5>：：NATURE：ChildOf：CWE ID：693：VIEW ID：1000：ORDINAL：Primary：：NATURE：ChildOf：CWE ID：693：VIEW ID：1003：ORDINAL：Primary：：NATURE：CanPrecede：CWE ID：22：VIEW ID：1000：：NATURE：CanPrecede：CWE ID：41：VIEW ID：1000：：NATURE：CanPrecede：CWE ID：74：VIEW ID：1000：：NATURE：CanPrecede：CWE ID：119：VIEW ID：1000：：
<h5>弱点规律</h5>空
<h5>适用的平台</h5>*语言类：语言-独立：语言普及率：未定：
<h5>背景细节</h5>空
<h5>替代条款</h5>空
<h5>模式的介绍</h5>*阶段：架构和Design：DESCRIPTION：PHASE：Implementation：DESCRIPTION：
<h5>剥削因素</h5>空
<h5>利用的可能性</h5>空
<h5>常见的后果</h5>：：SCOPE：Availability：TECHNICAL IMPACT：DoS：Crash，Exit，or Restart DoS：Resource Consumption(CPU)DoS：Resource Consumption(Memory)：NOTE：Availability DoS：Crash，Exit，or Restart DoS：Resource Consumption(CPU)DoS：Resource Consumption(Memory)An attacker could provide unexpected values and cause a program crash or excessive consumption of resources，such as memory and CPU.：：SCOPE：Confidentiality：TECHNICAL IMPACT：Read Memory Read Files or Directories：NOTE：Confidentiality Read Memory Read Files or Directories An attacker could read confidential data if they are able要控制资源references.：：SCOPE：Integrity：SCOPE：Confidentiality：SCOPE：Availability：TECHNICAL影响：修改内存、执行未经授权的代码或命令：注意：完整性、机密性、可用性、修改内存、执行未经授权的代码或命令，攻击者可以使用恶意输入来修改数据或可能以意外的方式更改控制流，包括任意命令执行。
<h5>检测方法</h5>::METHOD:Automated Static Analysis:EFFECTIVENESS::DESCRIPTION:Some instances of improper input validation can be detected using automated static analysis. A static analysis tool might allow the user to specify which application-specific methods or functions perform input validation; the tool might also have built-in knowledge of validation frameworks such as Struts. The tool may then suppress or de-prioritize any associated warnings. This allows the analyst to focus on areas of the software in which input validation does not appear to be present. Except in the cases described in the previous paragraph, automated static analysis might not be able to recognize when proper input validation is being performed, leading to false positives - i.e., warnings that do not have any security consequences or require any code changes.::METHOD:Manual Static Analysis:EFFECTIVENESS::DESCRIPTION:When custom input validation is required, such as when enforcing business rules, manual analysis is necessary to ensure that the validation is properly implemented.::METHOD:Fuzzing:EFFECTIVENESS::DESCRIPTION:Fuzzing techniques can be useful for detecting input validation errors. When unexpected inputs are provided to the software, the software should not crash or otherwise become unstable, and it should generate application-controlled error messages. If exceptions or interpreter-generated error messages occur, this indicates that the input was not detected and handled within the application logic itself.::METHOD:Automated Static Analysis - Binary or Bytecode:EFFECTIVENESS:SOAR Partial:DESCRIPTION:According to SOAR, the following detection techniques may be useful: Cost effective for partial coverage: Bytecode Weakness Analysis - including disassembler + source code weakness analysis Binary Weakness Analysis - including disassembler + source code weakness analysis::METHOD:Manual Static Analysis - Binary or Bytecode:EFFECTIVENESS:SOAR Partial:DESCRIPTION:According to SOAR, the following detection techniques may be useful: Cost effective for partial coverage: Binary / Bytecode disassembler - then use manual analysis for vulnerabilities & anomalies::METHOD:Dynamic Analysis with Automated Results Interpretation:EFFECTIVENESS:High:DESCRIPTION:According to SOAR, the following detection techniques may be useful: Highly cost effective: Web Application Scanner Web Services Scanner Database Scanners::METHOD:Dynamic Analysis with Manual Results Interpretation:EFFECTIVENESS:High:DESCRIPTION:According to SOAR, the following detection techniques may be useful: Highly cost effective: Fuzz Tester Framework-based Fuzzer Cost effective for partial coverage: Host Application Interface Scanner Monitored Virtual Environment - run potentially malicious code in sandbox / wrapper / virtual machine, see if it does anything suspicious::METHOD:Manual Static Analysis - Source Code:EFFECTIVENESS:High:DESCRIPTION:According to SOAR, the following detection techniques may be useful: Highly cost effective: Focused Manual Spotcheck - Focused manual analysis of source Manual Source Code Review (not inspections)::METHOD:Automated Static Analysis - Source Code:EFFECTIVENESS:High:DESCRIPTION:According to SOAR, the following detection techniques may be useful: Highly cost effective: Source code Weakness Analyzer Context-configured Source Code Weakness Analyzer::METHOD:Architecture or Design Review:EFFECTIVENESS:High:DESCRIPTION:According to SOAR, the following detection techniques may be useful: Highly cost effective: Inspection (IEEE 1028 standard) (can apply to requirements, design, source code, etc.) Formal Methods / Correct-By-Construction Cost effective for partial coverage: Attack Modeling::
<h5>潜在的缓解措施</h5>::PHASE:Architecture and Design:STRATEGY:Input Validation:EFFECTIVENESS::DESCRIPTION:Use an input validation framework such as Struts or the OWASP ESAPI Validation API. If you use Struts, be mindful of weaknesses covered by the CWE-101 category.::PHASE:Architecture and Design:STRATEGY:Libraries or Frameworks:EFFECTIVENESS::DESCRIPTION:Use an input validation framework such as Struts or the OWASP ESAPI Validation API. If you use Struts, be mindful of weaknesses covered by the CWE-101 category.::PHASE:Architecture and Design Implementation:STRATEGY:Attack Surface Reduction:EFFECTIVENESS::DESCRIPTION:Understand all the potential areas where untrusted inputs can enter your software: parameters or arguments, cookies, anything read from the network, environment variables, reverse DNS lookups, query results, request headers, URL components, e-mail, files, filenames, databases, and any external systems that provide data to the application. Remember that such inputs may be obtained indirectly through API calls.::PHASE:Implementation:STRATEGY:Input Validation:EFFECTIVENESS::DESCRIPTION:Assume all input is malicious. Use an accept known good input validation strategy, i.e., use a whitelist of acceptable inputs that strictly conform to specifications. Reject any input that does not strictly conform to specifications, or transform it into something that does. When performing input validation, consider all potentially relevant properties, including length, type of input, the full range of acceptable values, missing or extra inputs, syntax, consistency across related fields, and conformance to business rules. As an example of business rule logic, boat may be syntactically valid because it only contains alphanumeric characters, but it is not valid if the input is only expected to contain colors such as red or blue. Do not rely exclusively on looking for malicious or malformed inputs (i.e., do not rely on a blacklist). A blacklist is likely to miss at least one undesirable input, especially if the code's environment changes. This can give attackers enough room to bypass the intended validation. However, blacklists can be useful for detecting potential attacks or determining which inputs are so malformed that they should be rejected outright.::PHASE:Architecture and Design:STRATEGY::EFFECTIVENESS::DESCRIPTION:For any security checks that are performed on the client side, ensure that these checks are duplicated on the server side, in order to avoid CWE-602. Attackers can bypass the client-side checks by modifying values after the checks have been performed, or by changing the client to remove the client-side checks entirely. Then, these modified values would be submitted to the server. Even though client-side checks provide minimal benefits with respect to server-side security, they are still useful. First, they can support intrusion detection. If the server receives input that should have been rejected by the client, then it may be an indication of an attack. Second, client-side error-checking can provide helpful feedback to the user about the expectations for valid input. Third, there may be a reduction in server-side processing time for accidental input errors, although this is typically a small savings.::PHASE:Implementation:STRATEGY::EFFECTIVENESS::DESCRIPTION:When your application combines data from multiple sources, perform the validation after the sources have been combined. The individual data elements may pass the validation step but violate the intended restrictions after they have been combined.::PHASE:Implementation:STRATEGY::EFFECTIVENESS::DESCRIPTION:Be especially careful to validate all input when invoking code that crosses language boundaries, such as from an interpreted language to native code. This could create an unexpected interaction between the language boundaries. Ensure that you are not violating any of the expectations of the language with which you are interfacing. For example, even though Java may not be susceptible to buffer overflows, providing a large argument in a call to native code might trigger an overflow.::PHASE:Implementation:STRATEGY::EFFECTIVENESS::DESCRIPTION:Directly convert your input type into the expected data type, such as using a conversion function that translates a string into a number. After converting to the expected data type, ensure that the input's values fall within the expected range of allowable values and that multi-field consistencies are maintained.::PHASE:Implementation:STRATEGY::EFFECTIVENESS::DESCRIPTION:Inputs should be decoded and canonicalized to the application's current internal representation before being validated (CWE-180, CWE-181). Make sure that your application does not inadvertently decode the same input twice (CWE-174). Such errors could be used to bypass whitelist schemes by introducing dangerous inputs after they have been checked. Use libraries such as the OWASP ESAPI Canonicalization control. Consider performing repeated canonicalization until your input does not change any more. This will avoid double-decoding and similar scenarios, but it might inadvertently modify inputs that are allowed to contain properly-encoded dangerous content.::PHASE:Implementation:STRATEGY::EFFECTIVENESS::DESCRIPTION:When exchanging data between components, ensure that both components are using the same character encoding. Ensure that the proper encoding is applied at each interface. Explicitly set the encoding you are using whenever the protocol allows you to do so.::PHASE:Testing:STRATEGY::EFFECTIVENESS::DESCRIPTION:Use automated static analysis tools that target this type of weakness. Many modern techniques use data flow analysis to minimize the number of false positives. This is not a perfect solution, since 100% accuracy and coverage are not feasible.::PHASE:Testing:STRATEGY::EFFECTIVENESS::DESCRIPTION:Use dynamic tools and techniques that interact with the software using large test suites with many diverse inputs, such as fuzz testing (fuzzing), robustness testing, and fault injection. The software's operation may slow down, but it should not become unstable, crash, or generate incorrect results.::
<h5>观察到的例子</h5>::REFERENCE:CVE-2008-5305:DESCRIPTION:Eval injection in Perl program using an ID that should only contain hyphens and numbers.:LINK:https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2008-5305REFERENCE:CVE-2008-2223:DESCRIPTION:SQL injection through an ID that was supposed to be numeric.:LINK:https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2008-2223REFERENCE:CVE-2008-3477:DESCRIPTION:lack of input validation in spreadsheet program leads to buffer overflows, integer overflows, array index errors, and memory corruption.:LINK:https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2008-3477REFERENCE:CVE-2008-3843:DESCRIPTION:insufficient validation enables XSS:LINK:https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2008-3843REFERENCE:CVE-2008-3174:DESCRIPTION:driver in security product allows code execution due to insufficient validation:LINK:https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2008-3174REFERENCE:CVE-2007-3409:DESCRIPTION:infinite loop from DNS packet with a label that points to itself:LINK:https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2007-3409REFERENCE:CVE-2006-6870:DESCRIPTION:infinite loop from DNS packet with a label that points to itself:LINK:https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2006-6870REFERENCE:CVE-2008-1303:DESCRIPTION:missing parameter leads to crash:LINK:https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2008-1303REFERENCE:CVE-2007-5893:DESCRIPTION:HTTP request with missing protocol version number leads to crash:LINK:https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2007-5893REFERENCE:CVE-2006-6658:DESCRIPTION:request with missing parameters leads to information exposure:LINK:https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2006-6658REFERENCE:CVE-2008-4114:DESCRIPTION:system crash with offset value that is inconsistent with packet size:LINK:https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2008-4114REFERENCE:CVE-2006-3790:DESCRIPTION:size field that is inconsistent with packet size leads to buffer over-read:LINK:https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2006-3790REFERENCE:CVE-2008-2309:DESCRIPTION:product uses a blacklist to identify potentially dangerous content, allowing attacker to bypass a warning:LINK:https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2008-2309REFERENCE:CVE-2008-3494:DESCRIPTION:security bypass via an extra header:LINK:https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2008-3494REFERENCE:CVE-2006-5462:DESCRIPTION:use of extra data in a signature allows certificate signature forging:LINK:https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2006-5462REFERENCE:CVE-2008-3571:DESCRIPTION:empty packet triggers reboot:LINK:https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2008-3571REFERENCE:CVE-2006-5525:DESCRIPTION:incomplete blacklist allows SQL injection:LINK:https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2006-5525REFERENCE:CVE-2008-1284:DESCRIPTION:NUL byte in theme name cause directory traversal impact to be worse:LINK:https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2008-1284REFERENCE:CVE-2008-0600:DESCRIPTION:kernel does not validate an incoming pointer before dereferencing it:LINK:https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2008-0600REFERENCE:CVE-2008-1738:DESCRIPTION:anti-virus product has insufficient input validation of hooked SSDT functions, allowing code execution:LINK:https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2008-1738REFERENCE:CVE-2008-1737:DESCRIPTION:anti-virus product allows DoS via zero-length field:LINK:https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2008-1737REFERENCE:CVE-2008-3464:DESCRIPTION:driver does not validate input from userland to the kernel:LINK:https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2008-3464REFERENCE:CVE-2008-2252:DESCRIPTION:kernel does not validate parameters sent in from userland, allowing code execution:LINK:https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2008-2252REFERENCE:CVE-2008-2374:DESCRIPTION:lack of validation of string length fields allows memory consumption or buffer over-read:LINK:https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2008-2374REFERENCE:CVE-2008-1440:DESCRIPTION:lack of validation of length field leads to infinite loop:LINK:https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2008-1440REFERENCE:CVE-2008-1625:DESCRIPTION:lack of validation of input to an IOCTL allows code execution:LINK:https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2008-1625REFERENCE:CVE-2008-3177:DESCRIPTION:zero-length attachment causes crash:LINK:https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2008-3177REFERENCE:CVE-2007-2442:DESCRIPTION:zero-length input causes free of uninitialized pointer:LINK:https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2007-2442REFERENCE:CVE-2008-5563:DESCRIPTION:crash via a malformed frame structure:LINK:https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2008-5563REFERENCE:CVE-2008-5285:DESCRIPTION:infinite loop from a long SMTP request:LINK:https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2008-5285REFERENCE:CVE-2008-3812:DESCRIPTION:router crashes with a malformed packet:LINK:https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2008-3812REFERENCE:CVE-2008-3680:DESCRIPTION:packet with invalid version number leads to NULL pointer dereference:LINK:https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2008-3680REFERENCE:CVE-2008-3660:DESCRIPTION:crash via multiple . characters in file extension:LINK:https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2008-3660
<h5>功能区域</h5>空
<h5>影响资源</h5>空
<h5>分类法映射</h5>TAXONOMY NAME：7 Pernicious Kingdoms：ENTRY NAME：Input validation and representation：TAXONOMY NAME：OWASP Top Ten 2004：ENTRY ID：A1：ENTRY NAME：Unvalidated Input：MAPPING FIT：CWE More Specific：TAXONOMY NAME：CERT C Secure Coding：ENTRY ID：ERR07-C：ENTRY NAME：Prefer functions that support error checking over equivalent functions that don‘t：TAXONOMY NAME：CERT C Secure Coding：ENTRY ID：FIO30-C：ENTRY NAME：Exclude user input from format strings：MAPPING FIT：CWE More Abstract：TAXONOMY NAME：CERT C Secure Coding：ENTRY ID：MEM10-C：ENTRY NAME：Define and use a pointer validation function：TAXONOMY NAME：WASC：ENTRY ID：20：ENTRY NAME：Improper Input Handling：TAXONOMY NAME：Software Fault Patterns：ENTRY ID：SFP25：ENTRY NAME：Tainted input to variable：：
<h5>相关的攻击模式</h5>：：10：：101：：104：：108：：109：：110：：13：：135：：136：：14：：182：：209：：22：：230：：231：：24：：250：：267：：28：：3：：31：：42：：43：：45：：46：：47：：473：：484：：52：：53：：588：：591：：592：：63：：64：：66：：67：：7：：71：：72：：73：：78：：79：：8：：80：：81：：83：：85：：88：：9：：99：：
<h5>笔记</h5>类型：关系：注意：CWE-116和CWE-20有着密切的联系，因为根据结构化消息的性质，正确的输入验证可以间接防止特殊字符更改结构化消息的含义。例如，通过验证一个数字ID字段应该只包含0-9个字符，程序员可以有效地防止注入攻击。但是，输入验证并不总是足够的，特别是当必须支持不太严格的数据类型时，例如自由格式文本。考虑将姓氏插入查询的SQL注入场景。名称O‘Reilly很可能通过验证步骤，因为它是英语中常见的姓氏。但是，它不能直接插入到数据库中，因为它包含“撇号”字符，需要转义或以其他方式中和。在这种情况下，去掉撇号可能会降低SQL注入的风险，但它会产生错误的行为，因为会记录错误的名称。：类型：适用的平台：注意：输入验证在从外部源接收数据的任何系统中都可能是一个问题。：类型：维护：注意：输入验证-不管是丢失的还是不正确的-是安全开发中非常重要和广泛的部分，因此它隐含在许多不同的弱点中。传统上，缓冲区溢出和XSS等问题被许多安全专业人员归类为输入验证问题。然而，输入验证不一定是避免此类问题的唯一可用保护机制，在某些情况下甚至还不够。CWE团队已经开始在研究概念视图(CWE-1000)中的链中捕捉这些微妙之处，但还需要做更多的工作。：type：术语表：注意：输入验证术语非常常见，但它以许多不同的方式使用。在某些情况下，它的使用可能掩盖真正的潜在弱点，或者以其他方式隐藏链接和复合关系。有些人使用输入验证作为一个通用术语，涵盖许多不同的中和技术，以确保输入是适当的，例如过滤、规范化和转义。另一些人则在更狭窄的上下文中使用这个术语，只是指在不改变输入的情况下检查输入是否符合预期。：类型：研究差距：注：对输入验证技术及其应用的分类研究不多。许多公开披露的漏洞只是将问题描述为输入验证，而没有提供更具体的细节，这些细节可能有助于更深入地理解验证技术及其可以防止或减少的弱点。与其他中和技术(如过滤和转换强制执行)相比，验证被过分强调。见脆弱性理论文件。

