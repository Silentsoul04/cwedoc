# ID: 131 - 缓冲区大小计算错误
<h5>名称</h5>缓冲区大小计算错误
<h5>弱点抽象</h5>底座
<h5>状态</h5>草案
<h5>描述</h5>软件在分配缓冲区时没有正确计算要使用的大小，这可能导致缓冲区溢出。
<h5>扩展描述</h5>空
<h5>相关的弱点</h5>*性质：子女：CWE ID：682：视图ID：1000：序数：原生：自然：子女：CWE ID：682：视图ID：699：序号：PRIMAL：CANPREED：CWE ID：119：View ID：1000：大自然：CWE ID：119：View ID：699：
<h5>弱点规律</h5>空
<h5>适用的平台</h5>*语文名称：C：语文流行率：待定：语文名称：C+：语文流行率：待定：
<h5>背景细节</h5>空
<h5>替代条款</h5>空
<h5>模式的介绍</h5>*阶段：执行：说明：
<h5>剥削因素</h5>空
<h5>利用的可能性</h5>空
<h5>常见的后果</h5>：：SCOPE：Integrity：SCOPE：Availability：SCOPE：Confidentiality：TECHNICAL影响：DoS：崩溃、退出或重新启动执行未授权代码或命令读取内存修改内存：注意：完整性可用性保密性DoS：崩溃、退出或重新启动执行未授权代码或命令读取内存修改内存，如果在内存分配上下文中使用了不正确的计算，则软件可能会创建小于或大于预期的缓冲区。如果分配的缓冲区小于预期，则可能导致超出范围的读或写(CWE-119)，可能导致崩溃、允许执行任意代码或公开敏感数据。
<h5>检测方法</h5>::METHOD:Automated Static Analysis:EFFECTIVENESS:High:DESCRIPTION:This weakness can often be detected using automated static analysis tools. Many modern tools use data flow analysis or constraint-based techniques to minimize the number of false positives. Automated static analysis generally does not account for environmental considerations when reporting potential errors in buffer calculations. This can make it difficult for users to determine which warnings should be investigated first. For example, an analysis tool might report buffer overflows that originate from command line arguments in a program that is not expected to run with setuid or other special privileges.::METHOD:Automated Dynamic Analysis:EFFECTIVENESS:Moderate:DESCRIPTION:This weakness can be detected using dynamic tools and techniques that interact with the software using large test suites with many diverse inputs, such as fuzz testing (fuzzing), robustness testing, and fault injection. The software's operation may slow down, but it should not become unstable, crash, or generate incorrect results.::METHOD:Manual Analysis:EFFECTIVENESS::DESCRIPTION:Manual analysis can be useful for finding this weakness, but it might not achieve desired code coverage within limited time constraints. This becomes difficult for weaknesses that must be considered for all inputs, since the attack surface can be too large.::METHOD:Manual Analysis:EFFECTIVENESS:High:DESCRIPTION:This weakness can be detected using tools and techniques that require manual (human) analysis, such as penetration testing, threat modeling, and interactive tools that allow the tester to record and modify an active session. Specifically, manual static analysis is useful for evaluating the correctness of allocation calculations. This can be useful for detecting overflow conditions (CWE-190) or similar weaknesses that might have serious security impacts on the program.::METHOD:Automated Static Analysis - Binary or Bytecode:EFFECTIVENESS:High:DESCRIPTION:According to SOAR, the following detection techniques may be useful: Highly cost effective: Bytecode Weakness Analysis - including disassembler + source code weakness analysis Binary Weakness Analysis - including disassembler + source code weakness analysis::METHOD:Manual Static Analysis - Binary or Bytecode:EFFECTIVENESS:SOAR Partial:DESCRIPTION:According to SOAR, the following detection techniques may be useful: Cost effective for partial coverage: Binary / Bytecode disassembler - then use manual analysis for vulnerabilities & anomalies::METHOD:Manual Static Analysis - Source Code:EFFECTIVENESS:SOAR Partial:DESCRIPTION:According to SOAR, the following detection techniques may be useful: Cost effective for partial coverage: Focused Manual Spotcheck - Focused manual analysis of source Manual Source Code Review (not inspections)::METHOD:Automated Static Analysis - Source Code:EFFECTIVENESS:High:DESCRIPTION:According to SOAR, the following detection techniques may be useful: Highly cost effective: Source code Weakness Analyzer Context-configured Source Code Weakness Analyzer Cost effective for partial coverage: Source Code Quality Analyzer::METHOD:Architecture or Design Review:EFFECTIVENESS:High:DESCRIPTION:According to SOAR, the following detection techniques may be useful: Highly cost effective: Formal Methods / Correct-By-Construction Cost effective for partial coverage: Inspection (IEEE 1028 standard) (can apply to requirements, design, source code, etc.)::
<h5>潜在的缓解措施</h5>::PHASE:Implementation:STRATEGY::EFFECTIVENESS::DESCRIPTION:When allocating a buffer for the purpose of transforming, converting, or encoding an input, allocate enough memory to handle the largest possible encoding. For example, in a routine that converts & characters to &amp; for HTML entity encoding, the output buffer needs to be at least 5 times as large as the input buffer.::PHASE:Implementation:STRATEGY::EFFECTIVENESS::DESCRIPTION:Understand the programming language's underlying representation and how it interacts with numeric calculation (CWE-681). Pay close attention to byte size discrepancies, precision, signed/unsigned distinctions, truncation, conversion and casting between types, not-a-number calculations, and how the language handles numbers that are too large or too small for its underlying representation. [REF-7] Also be careful to account for 32-bit, 64-bit, and other potential differences that may affect the numeric representation.::PHASE:Implementation:STRATEGY:Input Validation:EFFECTIVENESS::DESCRIPTION:Perform input validation on any numeric input by ensuring that it is within the expected range. Enforce that the input meets both the minimum and maximum requirements for the expected range.::PHASE:Architecture and Design:STRATEGY::EFFECTIVENESS::DESCRIPTION:For any security checks that are performed on the client side, ensure that these checks are duplicated on the server side, in order to avoid CWE-602. Attackers can bypass the client-side checks by modifying values after the checks have been performed, or by changing the client to remove the client-side checks entirely. Then, these modified values would be submitted to the server.::PHASE:Implementation:STRATEGY::EFFECTIVENESS::DESCRIPTION:When processing structured incoming data containing a size field followed by raw data, identify and resolve any inconsistencies between the size field and the actual size of the data (CWE-130).::PHASE:Implementation:STRATEGY::EFFECTIVENESS::DESCRIPTION:When allocating memory that uses sentinels to mark the end of a data structure - such as NUL bytes in strings - make sure you also include the sentinel in your calculation of the total amount of memory that must be allocated.::PHASE:Implementation:STRATEGY::EFFECTIVENESS:Moderate:DESCRIPTION:Replace unbounded copy functions with analogous functions that support length arguments, such as strcpy with strncpy. Create these if they are not available.::PHASE:Implementation:STRATEGY::EFFECTIVENESS::DESCRIPTION:Use sizeof() on the appropriate data type to avoid CWE-467.::PHASE:Implementation:STRATEGY::EFFECTIVENESS::DESCRIPTION:Use the appropriate type for the desired action. For example, in C/C++, only use unsigned types for values that could never be negative, such as height, width, or other numbers related to quantity. This will simplify sanity checks and will reduce surprises related to unexpected casting.::PHASE:Architecture and Design:STRATEGY:Libraries or Frameworks:EFFECTIVENESS::DESCRIPTION:Use a vetted library or framework that does not allow this weakness to occur or provides constructs that make this weakness easier to avoid. Use libraries or frameworks that make it easier to handle numbers without unexpected consequences, or buffer allocation routines that automatically track buffer size. Examples include safe integer handling packages such as SafeInt (C++) or IntegerLib (C or C++). [REF-106]::PHASE:Build and Compilation:STRATEGY:Compilation or Build Hardening:EFFECTIVENESS:Defense in Depth:DESCRIPTION:Run or compile the software using features or extensions that automatically provide a protection mechanism that mitigates or eliminates buffer overflows. For example, certain compilers and extensions provide automatic buffer overflow detection mechanisms that are built into the compiled code. Examples include the Microsoft Visual Studio /GS flag, Fedora/Red Hat FORTIFY_SOURCE GCC flag, StackGuard, and ProPolice.::PHASE:Operation:STRATEGY:Environment Hardening:EFFECTIVENESS:Defense in Depth:DESCRIPTION:Run or compile the software using features or extensions that randomly arrange the positions of a program's executable and libraries in memory. Because this makes the addresses unpredictable, it can prevent an attacker from reliably jumping to exploitable code. Examples include Address Space Layout Randomization (ASLR) [REF-58] [REF-60] and Position-Independent Executables (PIE) [REF-64].::PHASE:Operation:STRATEGY:Environment Hardening:EFFECTIVENESS:Defense in Depth:DESCRIPTION:Use a CPU and operating system that offers Data Execution Protection (NX) or its equivalent [REF-61] [REF-60].::PHASE:Implementation:STRATEGY:Compilation or Build Hardening:EFFECTIVENESS::DESCRIPTION:Examine compiler warnings closely and eliminate problems with potential security implications, such as signed / unsigned mismatch in memory operations, or use of uninitialized variables. Even if the weakness is rarely exploitable, a single failure may lead to the compromise of the entire system.::PHASE:Architecture and Design Operation:STRATEGY:Environment Hardening:EFFECTIVENESS::DESCRIPTION:Run your code using the lowest privileges that are required to accomplish the necessary tasks [REF-76]. If possible, create isolated accounts with limited privileges that are only used for a single task. That way, a successful attack will not immediately give the attacker access to the rest of the software or its environment. For example, database applications rarely need to run as the database administrator, especially in day-to-day operations.::PHASE:Architecture and Design Operation:STRATEGY:Sandbox or Jail:EFFECTIVENESS:Limited:DESCRIPTION:Run the code in a jail or similar sandbox environment that enforces strict boundaries between the process and the operating system. This may effectively restrict which files can be accessed in a particular directory or which commands can be executed by the software. OS-level examples include the Unix chroot jail, AppArmor, and SELinux. In general, managed code may provide some protection. For example, java.io.FilePermission in the Java SecurityManager allows the software to specify restrictions on file operations. This may not be a feasible solution, and it only limits the impact to the operating system; the rest of the application may still be subject to compromise. Be careful to avoid CWE-243 and other weaknesses related to jails.::
<h5>观察到的例子</h5>：：REFERENCE：CVE-2004-1363：DESCRIPTION：substitution overflow：buffer overflow using environment variables that are expanded after the length check is performed：LINK：https：//cve.mitre.org/cgi-bin/cvename.cgi？name=CVE-2004-1363REFERENCE：CVE-2004-0747：DESCRIPTION：substitution overflow：buffer overflow using expansion of environment variables：LINK：https：//cve.mitre.org/cgi-bin/cvename.cgi？name=CVE-2004-0747REFERENCE：CVE-2005-2103：DESCRIPTION：substitution overflow：buffer overflow using a large number of substitution strings：LINK：https：//cve.mitre.org/cgi-bin/cvename.cgi？name=CVE-2005-2103REFERENCE：CVE-2005-3120：DESCRIPTION：transformation overflow：product adds extra escape characters to incoming data，but does not account for them in the buffer length：LINK：https：//cve.mitre.org/cgi-bin/cvename.cgi？name=CVE-2005-3120REFERENCE：CVE-2003-0899：DESCRIPTION：transformation overflow：buffer overflow when expanding>to&gt；，etc.：LINK：https：//cve.mitre.org/cgi-bin/cvename.cgi？name=CVE-2003-0899REFERENCE：CVE-2001-0334：DESCRIPTION：expansion overflow：buffer overflow using wildcards：LINK：https：//cve.mitre.org/cgi-bin/cvename.cgi？name=CVE-2001-0334REFERENCE：CVE-2001-0248：DESCRIPTION：expansion overflow：long pathname+glob=overflow：LINK：https：//cve.mitre.org/cgi-bin/cvename.cgi？name=CVE-2001-0248REFERENCE：CVE-2001-0249：DESCRIPTION：expansion overflow：long pathname+glob=overflow：LINK：https：//cve.mitre.org/cgi-bin/cvename.cgi？name=CVE-2001-0249REFERENCE：CVE-2002-0184：DESCRIPTION：special characters in argument are not properly expanded：LINK：https：//cve.mitre.org/cgi-bin/cvename.cgi？name=CVE-2002-0184REFERENCE：CVE-2004-0434：DESCRIPTION：small length value leads to heap overflow：LINK：https：//cve.mitre.org/cgi-bin/cvename.cgi？name=CVE-2004-0434REFERENCE：CVE-2002-1347：DESCRIPTION：multiple variants：LINK：https：//cve.mitre.org/cgi-bin/cvename.cgi？name=CVE-2002-1347REFERENCE：CVE-2005-0490：DESCRIPTION：needs closer investigation，but probably expansion-based：LINK：https：//cve.mitre.org/cgi-bin/cvename.cgi？name=CVE-2005-0490REFERENCE：CVE-2004-0940：DESCRIPTION：needs closer investigation，but probably expansion-based：LINK：https：//cve.mitre.org/cgi-bin/cvename.cgi？name=CVE-2004-0940REFERENCE：CVE-2008-0599：DESCRIPTION：Chain：Language interpreter calculates wrong buffer size(CWE-131)by using size=ptr？X：y而不是大小=(PTR？X：Y)expression.：LINK：https：//cve.mitre.org/cgi-bin/cvename.cgi？name=CVE-2008-0599
<h5>功能区域</h5>空
<h5>影响资源</h5>空
<h5>分类法映射</h5>分类法名称：plover：条目名称：其他长度计算错误：分类法名称：cert C安全编码：条目ID：INT 30-C：条目名称：确保无符号整数操作不包装：映射适合：不精确：分类法名称：cert C安全编码：条目ID：MEM 35-C：条目名称：为一个对象分配足够的内存：映射适合：CWE更抽象：
<h5>相关的攻击模式</h5>*100：47：
<h5>笔记</h5>类型：维护：注意：这是一个广泛的类别。一些例子包括：简单的数学错误，错误地更新并行计数器，在将一个输入转换为另一个格式时没有考虑到大小差异(例如URL规范化或其他可能产生比原始输入更大的结果的转换，即扩展)。这种详细程度很少出现在公开报告中，因此很难找到好的例子：类型：维护：注意：这个弱点可能是一个复合的或一个链。它还可能包含分层或透视差异。此问题可能与许多不同类型的不正确计算(CWE-682)有关，尽管整数溢出(CWE-190)可能是最常见的。这可能是资源消耗问题(CWE-400)的主要原因，包括不受控制的内存分配(CWE-789)。但是，还必须考虑到它与越界缓冲区访问(CWE-119)之间的关系。

