# ID: 609 - 二次检查锁定
<h5>名称</h5>二次检查锁定
<h5>弱点抽象</h5>底座
<h5>状态</h5>草案
<h5>描述</h5>该程序使用双重检查锁定来访问资源，而不需要显式同步的开销，但是锁定是不够的。
<h5>扩展描述</h5>双重检查锁定是指程序员检查某个资源是否已初始化、获取一个锁、再次检查该资源是否已初始化，然后在尚未发生的情况下执行初始化的情况。不应该这样做，因为不能保证在所有语言和所有体系结构上都能工作。总之，其他线程可能不会在同步块中操作，也不一定会看到这些操作以与它们在同步块中出现的顺序相同的顺序执行。
<h5>相关的弱点</h5>*性质：子女：CWE ID：667：View ID：1000：ORDINAL：Primary：：NATURE：CanPrecede：CWE ID：367：ViewID：1000：
<h5>弱点规律</h5>空
<h5>适用的平台</h5>*语言名称：Java：语言流行率：未定：
<h5>背景细节</h5>空
<h5>替代条款</h5>空
<h5>模式的介绍</h5>*阶段：执行：说明：
<h5>剥削因素</h5>空
<h5>利用的可能性</h5>空
<h5>常见的后果</h5>*范围：完整性：范围：其他：技术影响：修改应用程序数据，更改执行逻辑：
<h5>检测方法</h5>空
<h5>潜在的缓解措施</h5>：：PHASE：Implementation：STRATEGY：：EFFECTIVENESS：：DESCRIPTION：While的双重检查锁定可以在某些语言中实现，它在1.5之前的Java中是固有的缺陷，并且在不损害平台独立性的情况下无法实现。在Java1.5之前，只知道使用同步关键字才能工作。从Java1.5开始，使用易失性关键字可以使双重检查锁定成功地工作，尽管对于它是否获得了足够的性能增益还存在一些争论。见参考资料：
<h5>观察到的例子</h5>空
<h5>功能区域</h5>空
<h5>影响资源</h5>空
<h5>分类法映射</h5>分类法名称：CET Java安全编码：条目ID：LCK10-J：条目名称：不要使用不正确的双重检查锁定成语形式：分类法名称：软件故障模式：条目ID：SFP 19：条目名称：缺失锁：
<h5>相关的攻击模式</h5>空
<h5>笔记</h5>空

