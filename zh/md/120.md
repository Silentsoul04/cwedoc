# ID: 120 - 没有检查输入大小的缓冲区副本(“经典缓冲区溢出”)
<h5>名称</h5>没有检查输入大小的缓冲区副本(“经典缓冲区溢出”)
<h5>弱点抽象</h5>底座
<h5>状态</h5>不完全
<h5>描述</h5>程序将输入缓冲区复制到输出缓冲区，而不验证输入缓冲区的大小小于输出缓冲区的大小，从而导致缓冲区溢出。
<h5>扩展描述</h5>当程序试图在缓冲区中放置比它能容纳的更多的数据时，或者当程序试图将数据放在缓冲区边界之外的内存区域时，就存在缓冲区溢出情况。最简单的错误类型，也是缓冲区溢出的最常见原因，是典型的情况，在这种情况下，程序在不限制复制多少的情况下复制缓冲区。其他变体也存在，但经典溢出的存在强烈表明程序员甚至没有考虑最基本的安全保护。
<h5>相关的弱点</h5>*性质：子女：CWE ID：119：视图ID：1000：序数：初级：自然：子女：CWE ID：119：视图ID：699：序号：主：性质：CWE ID：123：视图ID：1000：自然：CWE ID：20：视图ID：700：序数：PRIMARE：CWE ID：123：视图ID：1000：自然：CWE ID：20：视图ID：700：序数：
<h5>弱点规律</h5>：：ORDINALITY：Resultant：DESCRIPTION：ORDINALITY：Primary：DESCRIPTION：
<h5>适用的平台</h5>*语文名称：C：语文流行率：待定：*语文名称：C+：语文流行率：语文类别：汇编：语文流行率：未定：
<h5>背景细节</h5>空
<h5>替代条款</h5>*术语：缓冲区溢出：一些知名供应商和研究人员使用缓冲区溢出一词，但大多数人使用缓冲区溢出。
<h5>模式的介绍</h5>*阶段：执行：说明：
<h5>剥削因素</h5>空
<h5>利用的可能性</h5>空
<h5>常见的后果</h5>：：SCOPE：Integrity：SCOPE：Confidentiality：SCOPE：Availability：TECHNICAL影响：执行未经授权的代码或命令：注意：完整性机密性、可用性执行未经授权的代码或命令缓冲区溢出通常可用于执行任意代码，这通常超出了程序的隐式安全策略的范围。这通常用于颠覆任何其他安全服务。：范围：可用性：技术影响：DoS：崩溃、退出或重新启动DoS：资源消耗(CPU)：注意：可用性DoS：崩溃、退出或重新启动DoS：资源消耗(CPU)缓冲区溢出通常会导致崩溃。其他导致缺乏可用性的攻击是可能的，包括将程序放入一个无限循环中。：
<h5>检测方法</h5>::METHOD:Automated Static Analysis:EFFECTIVENESS:High:DESCRIPTION:This weakness can often be detected using automated static analysis tools. Many modern tools use data flow analysis or constraint-based techniques to minimize the number of false positives. Automated static analysis generally does not account for environmental considerations when reporting out-of-bounds memory operations. This can make it difficult for users to determine which warnings should be investigated first. For example, an analysis tool might report buffer overflows that originate from command line arguments in a program that is not expected to run with setuid or other special privileges.::METHOD:Automated Dynamic Analysis:EFFECTIVENESS::DESCRIPTION:This weakness can be detected using dynamic tools and techniques that interact with the software using large test suites with many diverse inputs, such as fuzz testing (fuzzing), robustness testing, and fault injection. The software's operation may slow down, but it should not become unstable, crash, or generate incorrect results.::METHOD:Manual Analysis:EFFECTIVENESS::DESCRIPTION:Manual analysis can be useful for finding this weakness, but it might not achieve desired code coverage within limited time constraints. This becomes difficult for weaknesses that must be considered for all inputs, since the attack surface can be too large.::METHOD:Automated Static Analysis - Binary or Bytecode:EFFECTIVENESS:High:DESCRIPTION:According to SOAR, the following detection techniques may be useful: Highly cost effective: Bytecode Weakness Analysis - including disassembler + source code weakness analysis Binary Weakness Analysis - including disassembler + source code weakness analysis::METHOD:Manual Static Analysis - Binary or Bytecode:EFFECTIVENESS:SOAR Partial:DESCRIPTION:According to SOAR, the following detection techniques may be useful: Cost effective for partial coverage: Binary / Bytecode disassembler - then use manual analysis for vulnerabilities & anomalies::METHOD:Dynamic Analysis with Automated Results Interpretation:EFFECTIVENESS:SOAR Partial:DESCRIPTION:According to SOAR, the following detection techniques may be useful: Cost effective for partial coverage: Web Application Scanner Web Services Scanner Database Scanners::METHOD:Dynamic Analysis with Manual Results Interpretation:EFFECTIVENESS:SOAR Partial:DESCRIPTION:According to SOAR, the following detection techniques may be useful: Cost effective for partial coverage: Fuzz Tester Framework-based Fuzzer::METHOD:Manual Static Analysis - Source Code:EFFECTIVENESS:SOAR Partial:DESCRIPTION:According to SOAR, the following detection techniques may be useful: Cost effective for partial coverage: Focused Manual Spotcheck - Focused manual analysis of source Manual Source Code Review (not inspections)::METHOD:Automated Static Analysis - Source Code:EFFECTIVENESS:High:DESCRIPTION:According to SOAR, the following detection techniques may be useful: Highly cost effective: Source code Weakness Analyzer Context-configured Source Code Weakness Analyzer::METHOD:Architecture or Design Review:EFFECTIVENESS:High:DESCRIPTION:According to SOAR, the following detection techniques may be useful: Highly cost effective: Formal Methods / Correct-By-Construction Cost effective for partial coverage: Inspection (IEEE 1028 standard) (can apply to requirements, design, source code, etc.)::
<h5>潜在的缓解措施</h5>::PHASE:Requirements:STRATEGY:Language Selection:EFFECTIVENESS::DESCRIPTION:Use a language that does not allow this weakness to occur or provides constructs that make this weakness easier to avoid. For example, many languages that perform their own memory management, such as Java and Perl, are not subject to buffer overflows. Other languages, such as Ada and C#, typically provide overflow protection, but the protection can be disabled by the programmer. Be wary that a language's interface to native code may still be subject to overflows, even if the language itself is theoretically safe.::PHASE:Architecture and Design:STRATEGY:Libraries or Frameworks:EFFECTIVENESS::DESCRIPTION:Use a vetted library or framework that does not allow this weakness to occur or provides constructs that make this weakness easier to avoid. Examples include the Safe C String Library (SafeStr) by Messier and Viega [REF-57], and the Strsafe.h library from Microsoft [REF-56]. These libraries provide safer versions of overflow-prone string-handling functions.::PHASE:Build and Compilation:STRATEGY:Compilation or Build Hardening:EFFECTIVENESS:Defense in Depth:DESCRIPTION:Run or compile the software using features or extensions that automatically provide a protection mechanism that mitigates or eliminates buffer overflows. For example, certain compilers and extensions provide automatic buffer overflow detection mechanisms that are built into the compiled code. Examples include the Microsoft Visual Studio /GS flag, Fedora/Red Hat FORTIFY_SOURCE GCC flag, StackGuard, and ProPolice.::PHASE:Implementation:STRATEGY::EFFECTIVENESS::DESCRIPTION:Consider adhering to the following rules when allocating and managing an application's memory: Double check that your buffer is as large as you specify. When using functions that accept a number of bytes to copy, such as strncpy(), be aware that if the destination buffer size is equal to the source buffer size, it may not NULL-terminate the string. Check buffer boundaries if accessing the buffer in a loop and make sure you are not in danger of writing past the allocated space. If necessary, truncate all input strings to a reasonable length before passing them to the copy and concatenation functions.::PHASE:Implementation:STRATEGY:Input Validation:EFFECTIVENESS::DESCRIPTION:Assume all input is malicious. Use an accept known good input validation strategy, i.e., use a whitelist of acceptable inputs that strictly conform to specifications. Reject any input that does not strictly conform to specifications, or transform it into something that does. When performing input validation, consider all potentially relevant properties, including length, type of input, the full range of acceptable values, missing or extra inputs, syntax, consistency across related fields, and conformance to business rules. As an example of business rule logic, boat may be syntactically valid because it only contains alphanumeric characters, but it is not valid if the input is only expected to contain colors such as red or blue. Do not rely exclusively on looking for malicious or malformed inputs (i.e., do not rely on a blacklist). A blacklist is likely to miss at least one undesirable input, especially if the code's environment changes. This can give attackers enough room to bypass the intended validation. However, blacklists can be useful for detecting potential attacks or determining which inputs are so malformed that they should be rejected outright.::PHASE:Architecture and Design:STRATEGY::EFFECTIVENESS::DESCRIPTION:For any security checks that are performed on the client side, ensure that these checks are duplicated on the server side, in order to avoid CWE-602. Attackers can bypass the client-side checks by modifying values after the checks have been performed, or by changing the client to remove the client-side checks entirely. Then, these modified values would be submitted to the server.::PHASE:Operation:STRATEGY:Environment Hardening:EFFECTIVENESS:Defense in Depth:DESCRIPTION:Run or compile the software using features or extensions that randomly arrange the positions of a program's executable and libraries in memory. Because this makes the addresses unpredictable, it can prevent an attacker from reliably jumping to exploitable code. Examples include Address Space Layout Randomization (ASLR) [REF-58] [REF-60] and Position-Independent Executables (PIE) [REF-64].::PHASE:Operation:STRATEGY:Environment Hardening:EFFECTIVENESS:Defense in Depth:DESCRIPTION:Use a CPU and operating system that offers Data Execution Protection (NX) or its equivalent [REF-60] [REF-61].::PHASE:Build and Compilation Operation:STRATEGY::EFFECTIVENESS::DESCRIPTION:Most mitigating technologies at the compiler or OS level to date address only a subset of buffer overflow problems and rarely provide complete protection against even that subset. It is good practice to implement strategies to increase the workload of an attacker, such as leaving the attacker to guess an unknown value that changes every program execution.::PHASE:Implementation:STRATEGY::EFFECTIVENESS:Moderate:DESCRIPTION:Replace unbounded copy functions with analogous functions that support length arguments, such as strcpy with strncpy. Create these if they are not available.::PHASE:Architecture and Design:STRATEGY:Enforcement by Conversion:EFFECTIVENESS::DESCRIPTION:When the set of acceptable objects, such as filenames or URLs, is limited or known, create a mapping from a set of fixed input values (such as numeric IDs) to the actual filenames or URLs, and reject all other inputs.::PHASE:Architecture and Design Operation:STRATEGY:Environment Hardening:EFFECTIVENESS::DESCRIPTION:Run your code using the lowest privileges that are required to accomplish the necessary tasks [REF-76]. If possible, create isolated accounts with limited privileges that are only used for a single task. That way, a successful attack will not immediately give the attacker access to the rest of the software or its environment. For example, database applications rarely need to run as the database administrator, especially in day-to-day operations.::PHASE:Architecture and Design Operation:STRATEGY:Sandbox or Jail:EFFECTIVENESS:Limited:DESCRIPTION:Run the code in a jail or similar sandbox environment that enforces strict boundaries between the process and the operating system. This may effectively restrict which files can be accessed in a particular directory or which commands can be executed by the software. OS-level examples include the Unix chroot jail, AppArmor, and SELinux. In general, managed code may provide some protection. For example, java.io.FilePermission in the Java SecurityManager allows the software to specify restrictions on file operations. This may not be a feasible solution, and it only limits the impact to the operating system; the rest of the application may still be subject to compromise. Be careful to avoid CWE-243 and other weaknesses related to jails.::
<h5>观察到的例子</h5>：：REFERENCE：CVE-2000-1094：DESCRIPTION：buffer overflow using command with long argument：LINK：https：//cve.mitre.org/cgi-bin/cvename.cgi？name=CVE-2000-1094REFERENCE：CVE-1999-0046：DESCRIPTION：buffer overflow in local program using long environment variable：LINK：https：//cve.mitre.org/cgi-bin/cvename.cgi？name=CVE-1999-0046REFERENCE：CVE-2002-1337：DESCRIPTION：buffer overflow in comment characters，when product increments a counter for a>but does not decrement for<：LINK：https：//cve.mitre.org/cgi-bin/cvename.cgi？name=CVE-2002-1337REFERENCE：CVE-2003-0595：DESCRIPTION：By replacing a valid cookie value with an extremely long string of characters，an attacker may overflow the application‘s buffers.：LINK：https：//cve.mitre.org/cgi-bin/cvename.cgi？name=CVE-2003-0595REFERENCE：CVE-2001-0191：DESCRIPTION：By replacing a valid cookie value with an extremely long string of characters，an attacker may overflow the application’s buffers.：LINK：https：//cve.mitre.org/cgi-bin/cvename.cgi？name=CVE-2001-0191
<h5>功能区域</h5>*内存管理
<h5>影响资源</h5>记忆：
<h5>分类法映射</h5>TAXONOMY NAME：PLOVER：ENTRY NAME：Unbounded Transfer(‘classic overflow’)：TAXONOMY NAME：7 Pernicious Kingdoms：ENTRY NAME：Buffer Overflow：TAXONOMY NAME：CLASP：ENTRY NAME：Buffer overflow：TAXONOMY NAME：OWASP Top Ten 2004：ENTRY ID：A1：ENTRY NAME：Unvalidated Input：MAPPING FIT：CWE More Specific：TAXONOMY NAME：OWASP Top Ten 2004：ENTRY ID：A5：ENTRY NAME：Buffer Overflows：MAPPING FIT：CWE More Specific：TAXONOMY NAME：CERT C Secure Coding：ENTRY ID：STR31-C：ENTRY NAME：Guarantee that storage for strings has sufficient space for character data and the null terminator：MAPPING FIT：Exact：TAXONOMY NAME：WASC：ENTRY ID：7：ENTRY NAME：Buffer Overflow：TAXONOMY NAME：Software Fault Patterns：ENTRY ID：SFP8：ENTRY NAME：Faulty Buffer Access：：
<h5>相关的攻击模式</h5>：：10：：100：：14：：24：：42：：44：：45：：46：：47：：67：：8：：9：：92：：
<h5>笔记</h5>类型：关系：注意：在代码级别上，基于堆栈的溢出和基于堆的溢出没有显着性差异，因此通常不需要区分它们。从攻击者的角度来看，它们可能有很大的不同，因为利用它们需要不同的技术。：类型：术语：注意：现在称为缓冲区溢出的许多问题与传统的溢出有本质上的不同，包括完全不同的依赖溢出利用技术的错误类型，例如整数号错误、整数溢出和格式字符串错误。这一不准确的术语可能使人难以确定报告的是哪一种变体。

