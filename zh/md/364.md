# ID: 364 - 信号处理器种族条件
<h5>名称</h5>信号处理器种族条件
<h5>弱点抽象</h5>底座
<h5>状态</h5>不完全
<h5>描述</h5>该软件使用了一个信号处理程序，它引入了竞赛条件。
<h5>扩展描述</h5>Race conditions frequently occur in signal handlers, since signal handlers support asynchronous actions. These race conditions have a variety of root causes and symptoms. Attackers may be able to exploit a signal handler race condition to cause the software state to be corrupted, possibly leading to a denial of service or even code execution. These issues occur when non-reentrant functions, or state-sensitive actions occur in the signal handler, where they may be called at any time. These behaviors can violate assumptions being made by the regular code that is interrupted, or by other signal handlers that may also be invoked. If these functions are called at an inopportune moment - such as while a non-reentrant function is already running - memory corruption could occur that may be exploitable for code execution. Another signal race condition commonly found occurs when free is called within a signal handler, resulting in a double free and therefore a write-what-where condition. Even if a given pointer is set to NULL after it has been freed, a race condition still exists between the time the memory was freed and the pointer was set to NULL. This is especially problematic if the same signal handler has been set for more than one signal -- since it means that the signal handler itself may be reentered. There are several known behaviors related to signal handlers that have received the label of signal handler race condition: Shared state (e.g. global data or static variables) that are accessible to both a signal handler and regular code Shared state between a signal handler and other signal handlers Use of non-reentrant functionality within a signal handler - which generally implies that shared state is being used. For example, malloc() and free() are non-reentrant because they may use global or static data structures for managing memory, and they are indirectly used by innocent-seeming functions such as syslog(); these functions could be exploited for memory corruption and, possibly, code execution. Association of the same signal handler function with multiple signals - which might imply shared state, since the same code and resources are accessed. For example, this can be a source of double-free and use-after-free weaknesses. Use of setjmp and longjmp, or other mechanisms that prevent a signal handler from returning control back to the original functionality While not technically a race condition, some signal handlers are designed to be called at most once, and being called more than once can introduce security problems, even when there are not any concurrent calls to the signal handler. This can be a source of double-free and use-after-free weaknesses. Signal handler vulnerabilities are often classified based on the absence of a specific protection mechanism, although this style of classification is discouraged in CWE because programmers often have a choice of several different mechanisms for addressing the weakness. Such protection mechanisms may preserve exclusivity of access to the shared resource, and behavioral atomicity for the relevant code: Avoiding shared state Using synchronization in the signal handler Using synchronization in the regular code Disabling or masking other signals, which provides atomicity (which effectively ensures exclusivity)
<h5>相关的弱点</h5>*性质：子女：CWE ID：362：视图ID：1000：序数：原生：自然：子级：CWE ID：362：视图ID：699：序号：主：性质：CWE ID：415：视图ID：1000：自然：CanPrecode：CWE ID：416：View ID：1000：大自然：CanPrecode：CWE ID：123：View ID：1000：
<h5>弱点规律</h5>空
<h5>适用的平台</h5>*语言名称：C：语言流行率：有时：语言名称：C+：语言流行率：有时：
<h5>背景细节</h5>空
<h5>替代条款</h5>空
<h5>模式的介绍</h5>*阶段：架构和Design：DESCRIPTION：PHASE：Implementation：DESCRIPTION：
<h5>剥削因素</h5>空
<h5>利用的可能性</h5>空
<h5>常见的后果</h5>：：SCOPE：Integrity：SCOPE：Confidentiality：SCOPE：Availability：TECHNICAL影响：修改应用程序数据修改内存DoS：崩溃、退出或重新启动执行未经授权的代码或命令：注意：完整性机密性可用性修改应用程序数据修改内存DoS：崩溃、退出或重新启动执行未经授权的代码或命令可能会导致数据损坏，并可能通过在意外时间修改全局变量或数据结构来执行任意代码，这违反了使用全局数据的代码的假设。：范围：访问控制：技术影响：增益特权或假设标识：注意：访问控制获得特权或假定身份如果信号处理程序中断了以特权执行的代码，则信号处理程序也可能以提升的权限执行，可能会使随后的攻击更加严重。：
<h5>检测方法</h5>空
<h5>潜在的缓解措施</h5>*阶段：需求：策略：语言选择：有效性：描述：使用一种不允许出现此弱点的语言，或提供更容易避免此弱点的结构。：阶段：体系结构和Design：STRATEGY：：EFFECTIVENESS：：DESCRIPTION：Design信号处理程序只设置标志，而不是执行复杂的功能。然后，可以在主程序loop.：：PHASE：Implementation：STRATEGY：：EFFECTIVENESS：：DESCRIPTION：Only中检查和操作这些标志，在信号处理程序中使用可重入函数。此外，在执行影响执行状态的异步操作时，请使用健全检查以确保状态是一致的：
<h5>观察到的例子</h5>：：REFERENCE：CVE-1999-0035：DESCRIPTION：Signal handler does not disable other signal handlers，allowing it to be interrupted，causing other functionality to access files/etc.with raised privileges：LINK：https：//cve.mitre.org/cgi-bin/cvename.cgi？name=CVE-1999-0035REFERENCE：CVE-2001-0905：DESCRIPTION：Attacker can send a signal while another signal handler is already running，leading to crash or execution with root privileges：LINK：https：//cve.mitre.org/cgi-bin/cvename.cgi？name=CVE-2001-0905REFERENCE：CVE-2001-1349：DESCRIPTION：unsafe calls to library functions from signal handler：LINK：https：//cve.mitre.org/cgi-bin/cvename.cgi？name=CVE-2001-1349REFERENCE：CVE-2004-0794：DESCRIPTION：SIGURG can be used to remotely interrupt signal handler；other variants exist：LINK：https：//cve.mitre.org/cgi-bin/cvename.cgi？name=CVE-2004-0794REFERENCE：CVE-2004-2259：DESCRIPTION：SIGCHLD signal to FTP server can cause crash under heavy load while executing non-reentrant functions like malloc/free.：LINK：https：//cve.mitre.org/cgi-bin/cvename.cgi？name=CVE-2004-2259
<h5>功能区域</h5>*进程间通信
<h5>影响资源</h5>系统流程：
<h5>分类法映射</h5>分类名称：plover：条目名称：信号处理程序争用条件：分类法名称：7有害王国：条目名称：分类法名称：CLASP：条目名称：争用条件：分类法名称：软件故障模式：入口ID：SFP 19：条目名称：缺失锁：
<h5>相关的攻击模式</h5>空
<h5>笔记</h5>类型：研究差距：注：可能是研究不足。：

