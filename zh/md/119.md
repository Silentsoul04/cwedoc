# ID: 119 - 内存缓冲区范围内操作的不当限制
<h5>名称</h5>内存缓冲区范围内操作的不当限制
<h5>弱点抽象</h5>班级，等级
<h5>状态</h5>可用
<h5>描述</h5>该软件对内存缓冲区执行操作，但它可以从缓冲区的预定边界之外的内存位置读取或写入存储器位置。
<h5>扩展描述</h5>某些语言允许直接寻址内存位置，并且不会自动确保这些位置对于正在引用的内存缓冲区有效。这可能导致对可能与其他变量、数据结构或内部程序数据相关联的内存位置执行读或写操作。因此，攻击者可能能够执行任意代码、更改预期的控制流、读取敏感信息或导致系统崩溃。
<h5>相关的弱点</h5>*性质：子女：CWE ID：118：视图ID：1000：序数：初级：自然：子女：CWE ID：118：视图ID：1003：序号：基本：自然：CWE ID：20：视图ID：700：序数：
<h5>弱点规律</h5>空
<h5>适用的平台</h5>*语文名称：C：语文流行率：经常：语文名称：C+：语文流行率：语言类别：汇编：语文流行率：未定：
<h5>背景细节</h5>空
<h5>替代条款</h5>*术语：内存腐败：描述：一般术语内存损坏通常用于描述在缓冲区界限之外写入内存的后果，而其根本原因不是来自固定起始位置的过量数据的顺序副本(即经典缓冲区溢出或CWE-120)。这可能包括错误的指针算法、由于初始化不完全或内存释放而访问无效指针等问题：
<h5>模式的介绍</h5>*阶段：架构和Design：DESCRIPTION：PHASE：Implementation：DESCRIPTION：PHASE：Operation：DESCRIPTION：
<h5>剥削因素</h5>空
<h5>利用的可能性</h5>空
<h5>常见的后果</h5>：：SCOPE：Integrity：SCOPE：Confidentiality：SCOPE：Availability：TECHNICAL影响：执行未经授权的代码或命令修改内存：注意：完整性机密性可用性执行未经授权的代码或命令修改内存，如果攻击者可以有效地控制可访问的内存，则可能执行任意代码，就像使用标准缓冲区溢出一样。如果攻击者能够覆盖指针的内存值(通常为32位或64位)，他们可以将函数指针重定向到自己的恶意代码。即使攻击者只能修改单个字节，也可以执行任意代码。有时，这是因为同样的问题可以被反复利用以达到同样的效果。其他情况下，是因为攻击者可以覆盖安全性(关键应用程序特定的数据)，例如指示用户是否受到administrator.：：SCOPE：Availability：SCOPE：Confidentiality：TECHNICAL影响的标志：读取内存DoS：崩溃、退出或重新启动DoS：资源消耗(Cpu)DoS：资源消耗(内存)：注意：可用性保密性读取内存DoS：崩溃、退出或重新启动DoS：资源消耗(Cpu)DoS：超出内存范围的资源消耗(内存)访问将很可能导致相关内存的损坏，也许是指令，可能会导致坠机。其他导致缺乏可用性的攻击是可能的，包括将程序置于一个无限循环中。：作用域：机密性：技术影响：读取内存：注意：在超出范围读取的情况下，攻击者可能有权访问敏感信息。如果敏感信息包含系统详细信息，例如当前缓冲区在内存中的位置，则此知识可用于制造进一步的攻击，可能会带来更严重的后果。
<h5>检测方法</h5>::METHOD:Automated Static Analysis:EFFECTIVENESS:High:DESCRIPTION:This weakness can often be detected using automated static analysis tools. Many modern tools use data flow analysis or constraint-based techniques to minimize the number of false positives. Automated static analysis generally does not account for environmental considerations when reporting out-of-bounds memory operations. This can make it difficult for users to determine which warnings should be investigated first. For example, an analysis tool might report buffer overflows that originate from command line arguments in a program that is not expected to run with setuid or other special privileges.::METHOD:Automated Dynamic Analysis:EFFECTIVENESS::DESCRIPTION:This weakness can be detected using dynamic tools and techniques that interact with the software using large test suites with many diverse inputs, such as fuzz testing (fuzzing), robustness testing, and fault injection. The software's operation may slow down, but it should not become unstable, crash, or generate incorrect results.::METHOD:Automated Static Analysis - Binary or Bytecode:EFFECTIVENESS:SOAR Partial:DESCRIPTION:According to SOAR, the following detection techniques may be useful: Cost effective for partial coverage: Binary / Bytecode Quality Analysis Bytecode Weakness Analysis - including disassembler + source code weakness analysis Binary Weakness Analysis - including disassembler + source code weakness analysis::METHOD:Manual Static Analysis - Binary or Bytecode:EFFECTIVENESS:SOAR Partial:DESCRIPTION:According to SOAR, the following detection techniques may be useful: Cost effective for partial coverage: Binary / Bytecode disassembler - then use manual analysis for vulnerabilities & anomalies::METHOD:Dynamic Analysis with Automated Results Interpretation:EFFECTIVENESS:SOAR Partial:DESCRIPTION:According to SOAR, the following detection techniques may be useful: Cost effective for partial coverage: Web Application Scanner Web Services Scanner Database Scanners::METHOD:Dynamic Analysis with Manual Results Interpretation:EFFECTIVENESS:SOAR Partial:DESCRIPTION:According to SOAR, the following detection techniques may be useful: Cost effective for partial coverage: Fuzz Tester Framework-based Fuzzer::METHOD:Manual Static Analysis - Source Code:EFFECTIVENESS:SOAR Partial:DESCRIPTION:According to SOAR, the following detection techniques may be useful: Cost effective for partial coverage: Focused Manual Spotcheck - Focused manual analysis of source Manual Source Code Review (not inspections)::METHOD:Automated Static Analysis - Source Code:EFFECTIVENESS:High:DESCRIPTION:According to SOAR, the following detection techniques may be useful: Highly cost effective: Source code Weakness Analyzer Context-configured Source Code Weakness Analyzer Cost effective for partial coverage: Source Code Quality Analyzer::METHOD:Architecture or Design Review:EFFECTIVENESS:High:DESCRIPTION:According to SOAR, the following detection techniques may be useful: Highly cost effective: Formal Methods / Correct-By-Construction Cost effective for partial coverage: Inspection (IEEE 1028 standard) (can apply to requirements, design, source code, etc.)::
<h5>潜在的缓解措施</h5>*阶段：要求：战略：语言选择：有效性：描述：使用一种不允许出现这一弱点的语言，或提供使这一弱点更容易避免的结构。例如，许多执行自己内存管理的语言(如Java和Perl)不受缓冲区溢出的影响。其他语言，如Ada和C#，通常提供溢出保护，但是程序员可以禁用这种保护。请注意，语言与本机代码的接口可能仍然会受到溢出的影响，即使语言本身在理论上是安全的。：阶段：体系结构和设计：策略：库或框架：有效性：描述：使用经过审查的库或框架，该库或框架不允许此弱点发生，或提供更容易避免此弱点的构造。示例包括Messier和Viega[ref-57]的安全C字符串库(SafeStr)和Microsoft[ref-56]的Strsecurity.h库。这些库提供了易于溢出的字符串处理功能的更安全版本。：阶段：构建和编译：策略：编译或构建强化：有效性：深度防御：描述：使用功能或扩展运行或编译软件，这些特性或扩展自动提供一种保护机制，以减轻或消除缓冲区溢出。例如，某些编译器和扩展提供了内置在编译代码中的自动缓冲区溢出检测机制。示例包括MicrosoftVisualStudio/GS标志、Fedora/RedHatfortify_SourceGCC标志、StackGuard和在分配和管理应用程序内存时遵循以下规则的ProPolice.：：PHASE：Implementation：STRATEGY：：EFFECTIVENESS：：DESCRIPTION：Consider：重复检查缓冲区是否与您指定的大小相同。当使用接受大量字节复制的函数(例如strncpy()时，请注意，如果目标缓冲区大小等于源缓冲区大小，则它可能不会空-终止字符串。如果在循环中访问缓冲区，请检查缓冲区边界，并确保不存在写入超过分配空间的危险。如果有必要，在将所有输入字符串传递给副本和连接functions.：：PHASE：Operation：STRATEGY：Environment之前，将它们截断到一个合理的长度：有效性：深度防御：描述：使用特性或扩展运行或编译软件，这些特性或扩展随机地排列程序的可执行文件和库在内存中的位置。因为这使得地址不可预测，因此可以防止攻击者可靠地跳转到可利用的代码。Examples include Address Space Layout Randomization(ASLR)[REF-58][REF-60]and Position-Independent Executables(PIE)[REF-64].：：PHASE：Operation：STRATEGY：Environment Hardening：EFFECTIVENESS：Defense in Depth：DESCRIPTION：Use a CPU and operating system that offers Data Execution Protection(NX)or its equivalent[REF-60][REF-61].：：PHASE：Implementation：STRATEGY：：EFFECTIVENESS：Moderate：DESCRIPTION：Replace unbounded copy functions with analogous functions that support length arguments，such as strcpy with strncpy.如果它们不可用，则创建它们。：
<h5>观察到的例子</h5>：：REFERENCE：CVE-2009-2550：DESCRIPTION：Classic stack-based buffer overflow in media player using a long entry in a playlist：LINK：https：//cve.mitre.org/cgi-bin/cvename.cgi？name=CVE-2009-2550REFERENCE：CVE-2009-2403：DESCRIPTION：Heap-based buffer overflow in media player using a long entry in a playlist：LINK：https：//cve.mitre.org/cgi-bin/cvename.cgi？name=CVE-2009-2403REFERENCE：CVE-2009-0689：DESCRIPTION：large precision value in a format string triggers overflow：LINK：https：//cve.mitre.org/cgi-bin/cvename.cgi？name=CVE-2009-0689REFERENCE：CVE-2009-0690：DESCRIPTION：negative offset value leads to out-of-bounds read：LINK：https：//cve.mitre.org/cgi-bin/cvename.cgi？name=CVE-2009-0690REFERENCE：CVE-2009-1532：DESCRIPTION：malformed inputs cause accesses of uninitialized or previously-deleted objects，leading to memory corruption：LINK：https：//cve.mitre.org/cgi-bin/cvename.cgi？name=CVE-2009-1532REFERENCE：CVE-2009-1528：DESCRIPTION：chain：lack of synchronization leads to memory corruption：LINK：https：//cve.mitre.org/cgi-bin/cvename.cgi？name=CVE-2009-1528REFERENCE：CVE-2009-0558：DESCRIPTION：attacker-controlled array index leads to code execution：LINK：https：//cve.mitre.org/cgi-bin/cvename.cgi？name=CVE-2009-0558REFERENCE：CVE-2009-0269：DESCRIPTION：chain：-1 value from a functioncall was intended to indicate an error，but is used as an array index instead.：LINK：https：//cve.mitre.org/cgi-bin/cvename.cgi？name=CVE-2009-0269REFERENCE：CVE-2009-0566：DESCRIPTION：chain：incorrect calculations lead to incorrect pointer dereference and memory corruption：LINK：https：//cve.mitre.org/cgi-bin/cvename.cgi？name=CVE-2009-0566REFERENCE：CVE-2009-1350：DESCRIPTION：product accepts crafted messages that lead to a dereference of an arbitrary pointer：LINK：https：//cve.mitre.org/cgi-bin/cvename.cgi？name=CVE-2009-1350REFERENCE：CVE-2009-0191：DESCRIPTION：chain：malformed input causes dereference of uninitialized memory：LINK：https：//cve.mitre.org/cgi-bin/cvename.cgi？name=CVE-2009-0191REFERENCE：CVE-2008-4113：DESCRIPTION：OS kernel trusts userland-supplied length value，allowing reading of sensitive information：LINK：https：//cve.mitre.org/cgi-bin/cvename.cgi？name=CVE-2008-4113REFERENCE：CVE-2003-0542：DESCRIPTION：buffer overflow involving a regular expression with a large number of captures：LINK：https：//cve.mitre.org/cgi-bin/cvename.cgi？name=CVE-2003-0542REFERENCE：CVE-2017-1000121：DESCRIPTION：chain：unchecked message size metadata allows整数溢出(CWE-190)导致缓冲区溢出(CWE-119).：LINK：https：//cve.mitre.org/cgi-bin/cvename.cgi？name=CVE-2017-1000121
<h5>功能区域</h5>空
<h5>影响资源</h5>记忆：
<h5>分类法映射</h5>TAXONOMY NAME：OWASP Top Ten 2004：ENTRY ID：A5：ENTRY NAME：Buffer Overflows：MAPPING FIT：Exact：TAXONOMY NAME：CERT C Secure Coding：ENTRY ID：ARR00-C：ENTRY NAME：Understand how arrays work：TAXONOMY NAME：CERT C Secure Coding：ENTRY ID：ARR30-C：ENTRY NAME：Do not form or use out-of-bounds pointers or array subscripts：MAPPING FIT：CWE More Abstract：TAXONOMY NAME：CERT C Secure Coding：ENTRY ID：ARR38-C：ENTRY NAME：Guarantee that library functions do not form invalid pointers：MAPPING FIT：CWE More Abstract：TAXONOMY NAME：CERT C Secure Coding：ENTRY ID：ENV01-C：ENTRY NAME：Do not make assumptions about the size of an environment variable：TAXONOMY NAME：CERTC Secure Coding：ENTRY ID：EXP39-C：ENTRY NAME：Do not access a variable through a pointer of an incompatible type：MAPPING FIT：Imprecise：TAXONOMY NAME：CERT C Secure Coding：ENTRY ID：FIO37-C：ENTRY NAME：Do not assume character data has been read：TAXONOMY NAME：CERT C Secure Coding：ENTRY ID：STR31-C：ENTRY NAME：Guarantee that storage for strings has sufficient space for character data and the null terminator：MAPPING FIT：CWE More Abstract：TAXONOMY NAME：CERT C Secure Coding：ENTRY ID：STR32-C：ENTRY NAME：Do not pass a non-null-terminated character sequence to a library function that期望字符串：映射适合：CWE更抽象：分类法名称：WASC：条目ID：7：条目名称：分类法名称：软件故障模式：入口ID：SFP 8：条目名称：错误缓冲区访问：
<h5>相关的攻击模式</h5>*10：100：14：24：42：44：45：46：47：8：9：
<h5>笔记</h5>类型：可应用的平台：注意：在没有内存管理支持的情况下，任何编程语言都可以尝试在内存缓冲区界限之外进行操作，但后果将因语言、平台和芯片架构而大不相同。

